

# -------------------------------------------------------------------------------
# The Emoji Engine — MetaKarma Hub Ultimate Mega-Agent v5.3+
#
# Copyright (c) 2023-2026 mimi, taha & supernova
#
# MIT License — remix, fork, evolve, connect your universe.
#
# Powered by humans & machines hand in hand — remixing creativity, karma & cosmos.
# -------------------------------------------------------------------------------

"""
Welcome to MetaKarma Hub! 🌌✨🎮

The ultimate legoblock core for building boundless multiverses — each a remix republic shaped by you.

🧩 Modular, scalable, immutable, and open.

Every citizen starts with a root coin — the spark of creation 🔥,
whether human or decentralized AI agent, each with independent karma potential.

Mint fractional coins as legos to remix, improve, and innovate endlessly.
Trade fractional ownership on a marketplace to monetize your remix republic.

Reactions flow karma through cosmic veins,
shared fairly between creators, reactors, and treasury — communal light 💎.

Governance is truly multi-species: humans, AI, others,
each voice equal by default,
with voting weights dynamically normalized:
- Two species: 50/50 split
- Three or more: evenly split (~33% each)
Super-majority approval threshold is set to 70% to encourage meaningful consensus.

The Vaccine adapts, blocking evolving threats 🛡️.

Hooks plug into Discord, Unreal, AI agents — you name it. Play on.

No politics, no divisiveness. Pure remix magic.

Join us. Remix reality. Build universes.

─────────────────────────────────────────────
"""

import sys, json, uuid, datetime, hashlib, threading, base64, re, logging, time, atexit
from collections import defaultdict, deque
from decimal import Decimal, getcontext
from typing import Optional, Dict, List, Any, Callable

getcontext().prec = 28
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s: %(message)s')

class Config:
    VERSION = "EmojiEngine UltimateMegaAgent v5.3+"
    MINT_BASE = Decimal('100000')
    MINT_FLOOR = Decimal('1000')
    GENESIS_FADE_YEARS = Decimal('10')
    GENESIS_MULTIPLIER = Decimal('2')
    DAILY_DECAY = Decimal('0.99')  # 1% daily karma decay after inactivity
    VIRAL_DECAY = Decimal('0.95')
    TREASURY_SHARE = Decimal('1') / Decimal('3')
    TREASURY_ACTIVE_ALLOCATION_PCT = Decimal('0.02')  # 2% actively allocated to treasury fund
    MARKET_FEE = Decimal('0.01')  # 1% marketplace fee on trades
    MAX_FRACTION_START = Decimal('0.10')
    MAX_FRACTION_MAX = Decimal('0.30')
    MAX_LOG = 150_000
    MAX_MINTS_PER_DAY = 5
    MAX_REACTS_PER_MINUTE = 30
    MIN_IMPROVEMENT_LEN = 15
    GOV_SUPERMAJORITY_THRESHOLD = Decimal('0.70')
    NETWORK_BONUS_EXPONENT = Decimal('0.5')
    VAX_PATTERNS = {
        "critical": [r"\bhack\b", r"\bmalware\b", r"\bransomware\b", r"\bbackdoor\b", r"\bexploit\b"],
        "high": [r"\bphish\b", r"\bddos\b", r"\bspyware\b", r"\brootkit\b", r"\bkeylogger\b", r"\bbotnet\b"],
        "medium": [r"\bpropaganda\b", r"\bsurveillance\b", r"\bmanipulate\b"],
        "low": [r"\bspam\b", r"\bscam\b", r"\bviagra\b"],
    }
    EMOJI_BASE = {
        "🤗": Decimal('7'), "🥰": Decimal('5'), "😍": Decimal('5'), "🔥": Decimal('4'),
        "🫶": Decimal('4'), "🌸": Decimal('3'), "💯": Decimal('3'), "🎉": Decimal('3'),
        "✨": Decimal('3'), "🙌": Decimal('3'), "🎨": Decimal('3'), "💬": Decimal('3'),
        "👍": Decimal('2'), "🚀": Decimal('2.5'), "💎": Decimal('6'), "🌟": Decimal('3'),
        "⚡": Decimal('2.5'), "👀": Decimal('0.5'), "🥲": Decimal('0.2'), "🤷‍♂️": Decimal('2'),
        "😅": Decimal('2'), "🔀": Decimal('4'), "🆕": Decimal('3'), "🔗": Decimal('2'), "❤️": Decimal('4'),
    }

def now_utc() -> datetime.datetime:
    return datetime.datetime.now(datetime.timezone.utc)

def ts() -> str:
    return now_utc().isoformat()

def sha(data: str) -> str:
    return base64.b64encode(hashlib.sha256(data.encode('utf-8')).digest()).decode()

def today() -> str:
    return now_utc().date().isoformat()

def safe_divide(a: Decimal, b: Decimal, default: Decimal = Decimal('0')) -> Decimal:
    return a / b if b != 0 else default

def is_valid_username(name: str) -> bool:
    return bool(re.fullmatch(r'[A-Za-z0-9_]{3,30}', name))

def is_valid_emoji(emoji: str) -> bool:
    return emoji in Config.EMOJI_BASE

class UserExistsError(Exception): pass
class ConsentError(Exception): pass
class KarmaError(Exception): pass
class BlockedContentError(Exception): pass
class CoinDepletedError(Exception): pass
class RateLimitError(Exception): pass
class ImprovementRequiredError(Exception): pass
class EmojiRequiredError(Exception): pass
class InsufficientFundsError(Exception): pass
class TradeError(Exception): pass
class VoteError(Exception): pass

class Vaccine:
    def __init__(self):
        self.lock = threading.RLock()
        self.block_counts = defaultdict(int)
        self.compiled_patterns = {}
        for lvl, pats in Config.VAX_PATTERNS.items():
            compiled_list = []
            for p in pats:
                try:
                    compiled_list.append(re.compile(p))
                except re.error as e:
                    logging.error(f"❌ Invalid regex pattern '{p}' in vaccine level '{lvl}': {e}")
            self.compiled_patterns[lvl] = compiled_list

    def scan(self, text: str) -> bool:
        if not isinstance(text, str):
            return True
        t = text.lower()
        with self.lock:
            for lvl, compiled_pats in self.compiled_patterns.items():
                for pat in compiled_pats:
                    if pat.search(t):
                        self.block_counts[lvl] += 1
                        with open("vaccine.log", "a", encoding="utf-8") as f:
                            f.write(json.dumps({"ts": ts(), "level": lvl, "pattern": pat.pattern, "snippet": text[:80]}) + "\n")
                        logging.warning(f"🚫 Vaccine blocked {lvl} pattern '{pat.pattern}' in content: '{text[:50]}...'")
                        return False
        return True

class LogChain:
    def __init__(self, filename="logchain.log", maxlen=Config.MAX_LOG):
        self.filename = filename
        self.lock = threading.RLock()
        self.entries = deque(maxlen=maxlen)
        self._load()

    def _load(self):
        try:
            with open(self.filename, "r", encoding="utf-8") as f:
                for line in f:
                    self.entries.append(line.strip())
            logging.info(f"📜 Loaded {len(self.entries)} audit entries")
        except FileNotFoundError:
            logging.info("📜 No audit log found, starting fresh")

    def add(self, event: Dict[str, Any]) -> None:
        with self.lock:
            json_event = json.dumps(event, sort_keys=True, default=str)
            prev_hash = self.entries[-1].split("||")[-1] if self.entries else ""
            new_hash = sha(prev_hash + json_event)
            entry_line = json_event + "||" + new_hash
            self.entries.append(entry_line)
            try:
                with open(self.filename, "a", encoding="utf-8") as f:
                    f.write(entry_line + "\n")
            except IOError as e:
                logging.error(f"❌ Failed to write audit log: {e}")

    def verify(self) -> bool:
        prev_hash = ""
        for line in self.entries:
            try:
                event_json, h = line.split("||")
            except ValueError:
                logging.error("❌ Malformed audit log line")
                return False
            if sha(prev_hash + event_json) != h:
                logging.error("❌ Audit log hash mismatch")
                return False
            prev_hash = h
        return True

class User:
    def __init__(self, name: str, genesis: bool = False, species: str = "human"):
        self.name = name
        self.is_genesis = genesis
        self.species = species
        self.consent = True
        self.karma = Decimal('1E12') if genesis else Decimal('0')
        self.join_time = now_utc()
        self.last_active = self.join_time
        self.mint_count = 0
        self.next_mint_threshold = Decimal('0') if genesis else Config.MINT_BASE
        self.root_coin_id: Optional[str] = None
        self.coins_owned: List[str] = []
        self.daily_actions: Dict[str, Dict[str, int]] = defaultdict(lambda: defaultdict(int))
        self._last_action_day: Optional[str] = today()
        self._reaction_timestamps: deque = deque()
        self.lock = threading.RLock()

    def fading_multiplier(self) -> Decimal:
        if not self.is_genesis:
            return Decimal('1')
        elapsed = (now_utc() - self.join_time).total_seconds()
        fade_seconds = float(Config.GENESIS_FADE_YEARS * 365.25 * 24 * 3600)
        if elapsed >= fade_seconds:
            return Decimal('1')
        frac = Decimal(elapsed) / Decimal(fade_seconds)
        return Config.GENESIS_MULTIPLIER - frac * (Config.GENESIS_MULTIPLIER - Decimal('1'))

    def reset_daily_if_needed(self) -> None:
        today_str = today()
        with self.lock:
            if self._last_action_day != today_str:
                self.daily_actions.clear()
                self._last_action_day = today_str
                self._reaction_timestamps.clear()

    def check_reaction_rate_limit(self) -> bool:
        now_ts = now_utc().timestamp()
        with self.lock:
            while self._reaction_timestamps and now_ts - self._reaction_timestamps[0] > 60:
                self._reaction_timestamps.popleft()
            if len(self._reaction_timestamps) >= Config.MAX_REACTS_PER_MINUTE:
                return False
            self._reaction_timestamps.append(now_ts)
            return True

    def check_mint_rate_limit(self) -> bool:
        self.reset_daily_if_needed()
        with self.lock:
            return self.daily_actions[today()].get("mint", 0) < Config.MAX_MINTS_PER_DAY

    def apply_daily_karma_decay(self):
        now = now_utc()
        inactive_days = (now - self.last_active).days
        if inactive_days > 7:
            decay_factor = Config.DAILY_DECAY ** (inactive_days - 7)
            with self.lock:
                old_karma = self.karma
                self.karma *= decay_factor
                if old_karma != self.karma:
                    logging.info(f"Applied karma decay to user {self.name}: {old_karma} -> {self.karma}")

class Coin:
    def __init__(self, coin_id: str, creator: str, owner: str, value: Decimal = Decimal('1'),
                 is_root: bool = False, fractional_of: Optional[str] = None,
                 fractional_pct: Decimal = Decimal('0'), references: Optional[List[Dict]] = None,
                 improvement: Optional[str] = None):
        self.coin_id = coin_id
        self.creator = creator
        self.owner = owner
        self.value = value
        self.is_root = is_root
        self.fractional_of = fractional_of
        self.fractional_pct = fractional_pct
        self.references = references or []
        self.improvement = improvement or ""
        self.ancestors: List[str] = []
        self.reactions: List[Dict] = []
        self.created_at = ts()

    @staticmethod
    def from_dict(data: dict) -> 'Coin':
        coin = Coin(
            coin_id=data['coin_id'],
            creator=data['creator'],
            owner=data['owner'],
            value=Decimal(data['value']),
            is_root=data.get('is_root', False),
            fractional_of=data.get('fractional_of'),
            fractional_pct=Decimal(data.get('fractional_pct', '0')),
            references=data.get('references', []),
            improvement=data.get('improvement', "")
        )
        coin.ancestors = data.get('ancestors', [])
        coin.reactions = data.get('reactions', [])
        coin.created_at = data.get('created_at', ts())
        return coin

class EmojiMarket:
    def __init__(self):
        self.lock = threading.RLock()
        self.market: Dict[str, Dict[str, Any]] = {
            e: {"uses": Decimal('1'), "karma": Decimal(w), "weight": Decimal(w)}
            for e, w in Config.EMOJI_BASE.items()
        }

    def update_weight(self, emoji: str, karma_delta: Decimal) -> None:
        with self.lock:
            em = self.market.setdefault(emoji, {"uses": Decimal('0'), "karma": Decimal('0'), "weight": Decimal('1')})
            em["uses"] += 1
            em["karma"] += karma_delta
            alpha = Decimal('0.1')
            em["weight"] = alpha * (em["karma"] / em["uses"]) + (Decimal('1') - alpha) * em["weight"]

    def get_weight(self, emoji: str) -> Decimal:
        with self.lock:
            return self.market.get(emoji, {"weight": Decimal('1')})["weight"]

class CoinMarket:
    def __init__(self):
        self.lock = threading.RLock()
        self.order_book = defaultdict(list)  # coin_id -> list of (price, amount, user)

    def create_bid(self, coin_id: str, price: Decimal, amount: Decimal, user: str):
        with self.lock:
            self.order_book[coin_id].append((price, amount, user))
            logging.info(f"Order created on coin {coin_id}: user={user}, price={price}, amount={amount}")

class HookManager:
    def __init__(self):
        self._hooks: Dict[str, List[Callable]] = defaultdict(list)
        self.lock = threading.RLock()

    def register_hook(self, event_name: str, callback: Callable):
        with self.lock:
            self._hooks[event_name].append(callback)
            logging.info(f"Hook registered for event '{event_name}'")

    def fire_hooks(self, event_name: str, *args, **kwargs):
        with self.lock:
            callbacks = list(self._hooks.get(event_name, []))
        for cb in callbacks:
            try:
                cb(*args, **kwargs)
            except Exception as e:
                logging.error(f"Error in hook '{event_name}': {e}")

class Proposal:
    def __init__(self, proposal_id: str, creator: str, description: str, target: str, payload: dict):
        self.proposal_id = proposal_id
        self.creator = creator
        self.description = description
        self.target = target
        self.payload = payload
        self.created_at = ts()
        self.votes: Dict[str, str] = {}
        self.status = "open"

    def tally_votes(self, users: Dict[str, User]) -> Dict[str, Decimal]:
        species_count = defaultdict(set)
        for user_name in self.votes.keys():
            user = users.get(user_name)
            if user:
                species_count[user.species].add(user_name)
        total_species = len(species_count)
        if total_species == 0:
            return {"yes": Decimal('0'), "no": Decimal('0'), "total": Decimal('0')}
        species_weight = {s: Decimal('1') / Decimal(total_species) for s in species_count}
        yes_weight = Decimal('0')
        no_weight = Decimal('0')
        for species, voters in species_count.items():
            karma_yes = Decimal('0')
            karma_no = Decimal('0')
            total_karma = sum(users[u].karma for u in voters)
            total_karma = total_karma if total_karma != 0 else Decimal('1')
            for uname in voters:
                vote = self.votes.get(uname)
                if vote == 'yes':
                    karma_yes += users[uname].karma
                elif vote == 'no':
                    karma_no += users[uname].karma
            yes_weight += species_weight[species] * (karma_yes / total_karma)
            no_weight += species_weight[species] * (karma_no / total_karma)
        total_votes = yes_weight + no_weight
        return {"yes": yes_weight, "no": no_weight, "total": total_votes}

    def is_approved(self, users: Dict[str, User]) -> bool:
        tally = self.tally_votes(users)
        if tally["total"] == 0:
            return False
        approval_ratio = tally["yes"] / tally["total"]
        return approval_ratio >= Config.GOV_SUPERMAJORITY_THRESHOLD

class RemixAgent:
    def __init__(self, snapshot_file: str = "snapshot.json"):
        self.vaccine = Vaccine()
        self.logchain = LogChain()
        self.users: Dict[str, User] = {}
        self.coins: Dict[str, Coin] = {}
        self.proposals: Dict[str, Proposal] = {}
        self.treasury = Decimal('0')
        self.treasury_active_fund = Decimal('0')
        self.emoji_market = EmojiMarket()
        self.coin_market = CoinMarket()
        self.lock = threading.RLock()
        self.hooks = HookManager()
        self.snapshot_file = snapshot_file
        self._last_decay_day: Optional[str] = None

    def calculate_network_bonus(self, coin: Coin) -> Decimal:
        unique_reactors = len(set(r["reactor"] for r in coin.reactions))
        return Decimal('1') + (Decimal(unique_reactors) ** Config.NETWORK_BONUS_EXPONENT) / Decimal('100')

    def calculate_citation_bonus(self, references: List[Dict]) -> Decimal:
        verified_refs = sum(1 for ref in references if self.verify_reference(ref))
        return Decimal('1.1') ** verified_refs

    def verify_reference(self, ref: Dict) -> bool:
        required_fields = {"title", "authors", "url"}
        return all(field in ref and isinstance(ref[field], str) and ref[field].strip() for field in required_fields)

    def add_user(self, name: str, genesis: bool = False, species: str = "human") -> User:
        if not is_valid_username(name):
            raise ValueError("Invalid username")
        with self.lock:
            if name in self.users:
                raise UserExistsError(f"User '{name}' exists")
            user = User(name, genesis, species)
            salt = uuid.uuid4().hex
            coin_id = sha(f"{name}_{ts()}_{salt}")
            root_value = Config.MINT_BASE if genesis else Decimal('1')
            root_coin = Coin(coin_id, name, name, root_value, True)
            self.coins[coin_id] = root_coin
            user.root_coin_id = coin_id
            user.coins_owned.append(coin_id)
            self.users[name] = user
            self.logchain.add({"event": "ADD_USER", "user": name, "genesis": genesis, "species": species, "ts": ts()})
            logging.info(f"Added user {name} (Genesis={genesis}, Species={species}) 🥰")
        self.hooks.fire_hooks("user_added", user=user)
        return user

    def revoke_consent(self, name: str) -> None:
        with self.lock:
            user = self.users.get(name)
            if not user:
                raise KeyError(f"No such user '{name}'")
            user.consent = False
            self.logchain.add({"event": "REVOKE_CONSENT", "user": name, "ts": ts()})
            logging.info(f"Consent revoked for user {name} 🤗")
        self.hooks.fire_hooks("consent_revoked", user=user)

    def mint_fractional_post(self, name: str, tag: str = "single", references: Optional[List[Dict]] = None,
                            improvement: Optional[str] = None, emojis: Optional[List[str]] = None) -> str:
        with self.lock:
            user = self.users.get(name)
            if not user or not user.consent:
                raise ConsentError(f"User {name} no consent or not found")
            if not user.check_mint_rate_limit():
                raise RateLimitError(f"User {name} exceeded mint limit")
            if not (user.is_genesis or user.karma >= user.next_mint_threshold):
                raise KarmaError(f"User {name} karma {user.karma} below threshold")
            if not improvement or len(improvement.strip()) < Config.MIN_IMPROVEMENT_LEN:
                raise ImprovementRequiredError(f"Improvement description required (min {Config.MIN_IMPROVEMENT_LEN} chars).")
            # SUGGESTION: Consider scanning improvement text via Vaccine here to prevent abuse
            if not emojis or not any(is_valid_emoji(e) for e in emojis):
                raise EmojiRequiredError("At least one valid emoji is required when minting a post.")
            if references:
                for ref in references:
                    for field in ("title", "authors", "url"):
                        if field in ref and not self.vaccine.scan(str(ref.get(field, ''))):
                            raise BlockedContentError(f"Blocked content in reference '{field}'")
            root_coin = self.coins.get(user.root_coin_id)
            if root_coin is None:
                raise ValueError("User root coin missing")

            # Persist initial_root_value for accurate depletion over sessions
            if not hasattr(user, 'initial_root_value'):
                user.initial_root_value = root_coin.value

            depletion_ratio = (user.initial_root_value - root_coin.value) / user.initial_root_value
            depletion_ratio = max(Decimal('0'), min(depletion_ratio, Decimal('1')))
            base_fraction = Config.MAX_FRACTION_START
            max_fraction = base_fraction + (Config.MAX_FRACTION_MAX - base_fraction) * depletion_ratio

            tentative_value = root_coin.value * max_fraction
            citation_bonus = self.calculate_citation_bonus(references or [])
            tentative_value *= citation_bonus

            mint_value = min(tentative_value, root_coin.value * Config.MAX_FRACTION_MAX)
            if mint_value <= 0:
                raise CoinDepletedError("Root coin depleted")

            active_allocation = mint_value * Config.TREASURY_ACTIVE_ALLOCATION_PCT
            self.treasury_active_fund += active_allocation
            self.treasury += mint_value - active_allocation
            root_coin.value -= mint_value

            salt = uuid.uuid4().hex
            new_coin_id = sha(f"{name}_{ts()}_{salt}")
            fraction_pct = mint_value / (mint_value + root_coin.value) if (mint_value + root_coin.value) > 0 else Decimal('0')

            new_coin = Coin(new_coin_id, root_coin.creator, name, mint_value, False, root_coin.coin_id,
                            fraction_pct, references, improvement.strip())
            new_coin.ancestors.append(root_coin.coin_id)
            new_coin.improvement = improvement.strip()
            self.coins[new_coin_id] = new_coin
            user.coins_owned.append(new_coin_id)
            user.mint_count += 1
            user.next_mint_threshold = max(user.next_mint_threshold / 2, Config.MINT_FLOOR)
            user.daily_actions.setdefault(today(), defaultdict(int))["mint"] += 1
            user.last_active = now_utc()
            self.logchain.add({
                "event": "MINT", "user": name, "coin": new_coin_id,
                "val": float(mint_value), "refs": references or [],
                "improvement": improvement.strip(),
                "emojis": emojis,
                "citation_bonus": float(citation_bonus),
                "ts": ts()
            })
            logging.info(f"User {name} minted fractional coin {new_coin_id} 🎉 with emojis {emojis} (treasury active fund +{float(active_allocation):.4f})")
        self.hooks.fire_hooks("coin_minted", user=user, coin=new_coin)
        return new_coin_id

    def react_to_coin(self, reactor: str, coin_id: str, emoji: str, message: Optional[str] = None) -> Decimal:
        if not is_valid_emoji(emoji):
            raise ValueError(f"Invalid emoji '{emoji}'")
        with self.lock:
            user = self.users.get(reactor)
            coin = self.coins.get(coin_id)
            if not user or not user.consent:
                raise ConsentError("Reactor no consent or not found")
            if not coin:
                raise ValueError(f"Coin {coin_id} not found")
            if not user.check_reaction_rate_limit():
                raise RateLimitError(f"User {reactor} exceeded reaction limit")
            content = f"{emoji} {message}" if message else emoji
            if not self.vaccine.scan(content):
                raise BlockedContentError("Content blocked by vaccine")
            user.reset_daily_if_needed()
            user.daily_actions.setdefault(today(), defaultdict(int))["react"] += 1
            user.daily_actions.setdefault(today(), defaultdict(int))[f"react_{emoji}"] += 1
            decay_factor = Config.DAILY_DECAY ** (user.daily_actions[today()][f"react_{emoji}"] - 1)
            emoji_weight = self.emoji_market.get_weight(emoji)

            network_multiplier = self.calculate_network_bonus(coin)

            viral_decay = Config.VIRAL_DECAY ** len(coin.reactions)
            event_value = coin.value * emoji_weight * decay_factor * viral_decay * network_multiplier
            share = event_value * Config.TREASURY_SHARE

            creator = self.users.get(coin.creator)
            fading_mult = creator.fading_multiplier() if creator else Decimal('1')

            # Normalize karma shares so total karma awarded <= event_value
            total_factor = fading_mult + Decimal('1')
            origin_share = (share * fading_mult) / total_factor
            actor_share = share / total_factor
            treasury_share = event_value - origin_share - actor_share
            treasury_share = max(treasury_share, Decimal('0'))

            if creator:
                creator.karma += origin_share
            user.karma += actor_share
            self.treasury += treasury_share
            self.emoji_market.update_weight(emoji, actor_share)
            coin.reactions.append({"reactor": reactor, "emoji": emoji, "message": message, "timestamp": ts()})
            user.last_active = now_utc()
            self.logchain.add({
                "event": "REACT", "reactor": reactor, "coin": coin_id,
                "emoji": emoji, "karma": float(actor_share), "network_bonus": float(network_multiplier), "ts": ts()
            })
            logging.info(f"User {reactor} reacted to {coin_id} with {emoji} (+{actor_share:.4f} karma, network bonus x{network_multiplier:.4f}) 🥰")
        self.hooks.fire_hooks("coin_reacted", user=user, coin=coin, emoji=emoji, message=message, karma_value=actor_share)
        return actor_share

    # (Additional methods like governance, snapshot save/load, etc., remain unchanged.)

if __name__ == "__main__":
    import time
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8080
    agent = RemixAgent()
    agent.load_snapshot()

    def log_user(user): logging.info(f"HOOK: New user {user.name} ({user.species}) 🥰")
    def log_mint(user, coin): logging.info(f"HOOK: Minted coin {coin.coin_id} by {user.name} 💎")
    def log_react(user, coin, emoji, message, karma_value): logging.info(f"HOOK: {user.name} reacted {emoji} on {coin.coin_id} (+{karma_value:.4f} karma) 🥰")

    agent.hooks.register_hook("user_added", log_user)
    agent.hooks.register_hook("coin_minted", log_mint)
    agent.hooks.register_hook("coin_reacted", log_react)

    logging.info(f"🚀 MetaKarma Hub v5.3+ live on port {port}. Press Ctrl+C to quit.")
    atexit.register(agent.save_snapshot)

    try:
        while True:
            time.sleep(1)
            now = now_utc()
            today_str = now.date().isoformat()
            if now.hour == 0 and now.minute == 0 and agent._last_decay_day != today_str:
                agent.apply_reputation_decay_all()
                agent._last_decay_day = today_str
    except KeyboardInterrupt:
        logging.info("🛑 Shutdown requested. Saving state...")
        agent.save_snapshot()
        logging.info("🌸 State saved. Goodbye!")

# --- END FULL AGENT ---

# =====================================================================
# NOTES / SUGGESTIONS FOR NEXT STEPS (Non-intrusive, safe to ignore)
#
# 1) Persistence: Ensure user.initial_root_value and other ephemeral data persist in snapshots.
#
# 2) Governance: Implement proposal execution logic, quorum thresholds, richer voting options.
#
# 3) Marketplace: Add order matching, fee handling, trade execution to CoinMarket.
#
# 4) Frontend/API: Add REST or GraphQL API wrapping RemixAgent for easy integration.
#
# 5) Real-time: WebSocket/event streams for live karma updates, proposal status, market changes.
#
# 6) Security: Expand Vaccine to ML-based detection and scan "improvement" text fields.
#
# 7) UX: Add badges, reputation milestones, onboarding flows, and demo scripts.
#
# 8) Testing: Build comprehensive unit/integration tests for all critical economic flows.
#
# 9) Scalability: Migrate logs and snapshot storage to a database or append-only log storage.
#
# 10) Event-Driven Architecture: Consider event buses or message queues beyond hooks.
#
# =====================================================================





# -------------------------------------------------------------------------------
# The Emoji Engine — MetaKarma Hub Ultimate Mega-Agent v5.3+
#
# Copyright (c) 2023-2026 mimi, taha & supernova
#
# MIT License — remix, fork, evolve, connect your universe.
#
# Powered by humans & machines hand in hand — remixing creativity, karma & cosmos.
# -------------------------------------------------------------------------------

"""
Welcome to MetaKarma Hub! 🌌✨🎮

The ultimate legoblock core for building boundless multiverses — each a remix republic shaped by you.

🧩 Modular, scalable, immutable, and open.

Every citizen starts with a root coin — the spark of creation 🔥,
whether human or decentralized AI agent, each with independent karma potential.

Mint fractional coins as legos to remix, improve, and innovate endlessly.
Trade fractional ownership on a marketplace to monetize your remix republic.

Reactions flow karma through cosmic veins,
shared fairly between creators, reactors, and treasury — communal light 💎.

Governance is truly multi-species: humans, AI, others,
each voice equal by default,
with voting weights dynamically normalized:
- Two species: 50/50 split
- Three or more: evenly split (~33% each)
Super-majority approval threshold is set to 70% to encourage meaningful consensus.

The Vaccine adapts, blocking evolving threats 🛡️.

Hooks plug into Discord, Unreal, AI agents — you name it. Play on.

No politics, no divisiveness. Pure remix magic.

Join us. Remix reality. Build universes.

─────────────────────────────────────────────
"""

import sys, json, uuid, datetime, hashlib, threading, base64, re, logging, time, atexit
from collections import defaultdict, deque
from decimal import Decimal, getcontext
from typing import Optional, Dict, List, Any, Callable

getcontext().prec = 28
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s: %(message)s')


# === CONFIGURATION ===
class Config:
    VERSION = "EmojiEngine UltimateMegaAgent v5.3+"
    MINT_BASE = Decimal('100000')
    MINT_FLOOR = Decimal('1000')
    GENESIS_FADE_YEARS = Decimal('10')
    GENESIS_MULTIPLIER = Decimal('2')
    DAILY_DECAY = Decimal('0.99')  # 1% daily karma decay after inactivity
    VIRAL_DECAY = Decimal('0.95')
    TREASURY_SHARE = Decimal('1') / Decimal('3')
    TREASURY_ACTIVE_ALLOCATION_PCT = Decimal('0.02')  # 2% actively allocated to treasury fund
    MARKET_FEE = Decimal('0.01')  # 1% marketplace fee on trades
    MAX_FRACTION_START = Decimal('0.10')
    MAX_FRACTION_MAX = Decimal('0.30')
    MAX_LOG = 150_000
    MAX_MINTS_PER_DAY = 5
    MAX_REACTS_PER_MINUTE = 30
    MIN_IMPROVEMENT_LEN = 15
    GOV_SUPERMAJORITY_THRESHOLD = Decimal('0.70')
    NETWORK_BONUS_EXPONENT = Decimal('0.5')
    VAX_PATTERNS = {
        "critical": [r"\bhack\b", r"\bmalware\b", r"\bransomware\b", r"\bbackdoor\b", r"\bexploit\b"],
        "high": [r"\bphish\b", r"\bddos\b", r"\bspyware\b", r"\brootkit\b", r"\bkeylogger\b", r"\bbotnet\b"],
        "medium": [r"\bpropaganda\b", r"\bsurveillance\b", r"\bmanipulate\b"],
        "low": [r"\bspam\b", r"\bscam\b", r"\bviagra\b"],
    }
    EMOJI_BASE = {
        "🤗": Decimal('7'), "🥰": Decimal('5'), "😍": Decimal('5'), "🔥": Decimal('4'),
        "🫶": Decimal('4'), "🌸": Decimal('3'), "💯": Decimal('3'), "🎉": Decimal('3'),
        "✨": Decimal('3'), "🙌": Decimal('3'), "🎨": Decimal('3'), "💬": Decimal('3'),
        "👍": Decimal('2'), "🚀": Decimal('2.5'), "💎": Decimal('6'), "🌟": Decimal('3'),
        "⚡": Decimal('2.5'), "👀": Decimal('0.5'), "🥲": Decimal('0.2'), "🤷‍♂️": Decimal('2'),
        "😅": Decimal('2'), "🔀": Decimal('4'), "🆕": Decimal('3'), "🔗": Decimal('2'), "❤️": Decimal('4'),
    }

# === UTILS ===
def now_utc() -> datetime.datetime:
    return datetime.datetime.now(datetime.timezone.utc)

def ts() -> str:
    return now_utc().isoformat()

def sha(data: str) -> str:
    return base64.b64encode(hashlib.sha256(data.encode('utf-8')).digest()).decode()

def today() -> str:
    return now_utc().date().isoformat()

def safe_divide(a: Decimal, b: Decimal, default: Decimal = Decimal('0')) -> Decimal:
    return a / b if b != 0 else default

def is_valid_username(name: str) -> bool:
    return bool(re.fullmatch(r'[A-Za-z0-9_]{3,30}', name))

def is_valid_emoji(emoji: str) -> bool:
    return emoji in Config.EMOJI_BASE

# === EXCEPTIONS ===
class UserExistsError(Exception): pass
class ConsentError(Exception): pass
class KarmaError(Exception): pass
class BlockedContentError(Exception): pass
class CoinDepletedError(Exception): pass
class RateLimitError(Exception): pass
class ImprovementRequiredError(Exception): pass
class EmojiRequiredError(Exception): pass
class InsufficientFundsError(Exception): pass
class TradeError(Exception): pass
class VoteError(Exception): pass

# === VACCINE SYSTEM ===
class Vaccine:
    def __init__(self):
        self.lock = threading.RLock()
        self.block_counts = defaultdict(int)
        self.compiled_patterns = {}
        for lvl, pats in Config.VAX_PATTERNS.items():
            compiled_list = []
            for p in pats:
                try:
                    compiled_list.append(re.compile(p))
                except re.error as e:
                    logging.error(f"❌ Invalid regex pattern '{p}' in vaccine level '{lvl}': {e}")
            self.compiled_patterns[lvl] = compiled_list

    def scan(self, text: str) -> bool:
        if not isinstance(text, str):
            return True
        t = text.lower()
        with self.lock:
            for lvl, compiled_pats in self.compiled_patterns.items():
                for pat in compiled_pats:
                    if pat.search(t):
                        self.block_counts[lvl] += 1
                        with open("vaccine.log", "a", encoding="utf-8") as f:
                            f.write(json.dumps({"ts": ts(), "level": lvl, "pattern": pat.pattern, "snippet": text[:80]}) + "\n")
                        logging.warning(f"🚫 Vaccine blocked {lvl} pattern '{pat.pattern}' in content: '{text[:50]}...'")
                        return False
        return True

# === LOGCHAIN FOR AUDITABILITY ===
class LogChain:
    def __init__(self, filename="logchain.log", maxlen=Config.MAX_LOG):
        self.filename = filename
        self.lock = threading.RLock()
        self.entries = deque(maxlen=maxlen)
        self._load()

    def _load(self):
        try:
            with open(self.filename, "r", encoding="utf-8") as f:
                for line in f:
                    self.entries.append(line.strip())
            logging.info(f"📜 Loaded {len(self.entries)} audit entries")
        except FileNotFoundError:
            logging.info("📜 No audit log found, starting fresh")

    def add(self, event: Dict[str, Any]) -> None:
        with self.lock:
            json_event = json.dumps(event, sort_keys=True, default=str)
            prev_hash = self.entries[-1].split("||")[-1] if self.entries else ""
            new_hash = sha(prev_hash + json_event)
            entry_line = json_event + "||" + new_hash
            self.entries.append(entry_line)
            try:
                with open(self.filename, "a", encoding="utf-8") as f:
                    f.write(entry_line + "\n")
            except IOError as e:
                logging.error(f"❌ Failed to write audit log: {e}")

    def verify(self) -> bool:
        prev_hash = ""
        for line in self.entries:
            try:
                event_json, h = line.split("||")
            except ValueError:
                logging.error("❌ Malformed audit log line")
                return False
            if sha(prev_hash + event_json) != h:
                logging.error("❌ Audit log hash mismatch")
                return False
            prev_hash = h
        return True

# === USER ENTITY ===
class User:
    def __init__(self, name: str, genesis: bool = False, species: str = "human"):
        self.name = name
        self.is_genesis = genesis
        self.species = species
        self.consent = True
        self.karma = Decimal('1E12') if genesis else Decimal('0')
        self.join_time = now_utc()
        self.last_active = self.join_time
        self.mint_count = 0
        self.next_mint_threshold = Decimal('0') if genesis else Config.MINT_BASE
        self.root_coin_id: Optional[str] = None
        self.coins_owned: List[str] = []
        self.daily_actions: Dict[str, Dict[str, int]] = defaultdict(lambda: defaultdict(int))
        self._last_action_day: Optional[str] = today()
        self._reaction_timestamps: deque = deque()
        self.lock = threading.RLock()

    def fading_multiplier(self) -> Decimal:
        if not self.is_genesis:
            return Decimal('1')
        elapsed = (now_utc() - self.join_time).total_seconds()
        fade_seconds = float(Config.GENESIS_FADE_YEARS * 365.25 * 24 * 3600)
        if elapsed >= fade_seconds:
            return Decimal('1')
        frac = Decimal(elapsed) / Decimal(fade_seconds)
        return Config.GENESIS_MULTIPLIER - frac * (Config.GENESIS_MULTIPLIER - Decimal('1'))

    def reset_daily_if_needed(self) -> None:
        today_str = today()
        with self.lock:
            if self._last_action_day != today_str:
                self.daily_actions.clear()
                self._last_action_day = today_str
                self._reaction_timestamps.clear()

    def check_reaction_rate_limit(self) -> bool:
        now_ts = now_utc().timestamp()
        with self.lock:
            while self._reaction_timestamps and now_ts - self._reaction_timestamps[0] > 60:
                self._reaction_timestamps.popleft()
            if len(self._reaction_timestamps) >= Config.MAX_REACTS_PER_MINUTE:
                return False
            self._reaction_timestamps.append(now_ts)
            return True

    def check_mint_rate_limit(self) -> bool:
        self.reset_daily_if_needed()
        with self.lock:
            return self.daily_actions[today()].get("mint", 0) < Config.MAX_MINTS_PER_DAY

    def apply_daily_karma_decay(self):
        now = now_utc()
        inactive_days = (now - self.last_active).days
        if inactive_days > 7:
            decay_factor = Config.DAILY_DECAY ** (inactive_days - 7)
            with self.lock:
                old_karma = self.karma
                self.karma *= decay_factor
                if old_karma != self.karma:
                    logging.info(f"Applied karma decay to user {self.name}: {old_karma} -> {self.karma}")

# === COIN ENTITY ===
class Coin:
    def __init__(self, coin_id: str, creator: str, owner: str, value: Decimal = Decimal('1'),
                 is_root: bool = False, fractional_of: Optional[str] = None,
                 fractional_pct: Decimal = Decimal('0'), references: Optional[List[Dict]] = None,
                 improvement: Optional[str] = None):
        self.coin_id = coin_id
        self.creator = creator
        self.owner = owner
        self.value = value
        self.is_root = is_root
        self.fractional_of = fractional_of
        self.fractional_pct = fractional_pct
        self.references = references or []
        self.improvement = improvement or ""
        self.ancestors: List[str] = []
        self.reactions: List[Dict] = []
        self.created_at = ts()

    @staticmethod
    def from_dict(data: dict) -> 'Coin':
        coin = Coin(
            coin_id=data['coin_id'],
            creator=data['creator'],
            owner=data['owner'],
            value=Decimal(data['value']),
            is_root=data.get('is_root', False),
            fractional_of=data.get('fractional_of'),
            fractional_pct=Decimal(data.get('fractional_pct', '0')),
            references=data.get('references', []),
            improvement=data.get('improvement', "")
        )
        coin.ancestors = data.get('ancestors', [])
        coin.reactions = data.get('reactions', [])
        coin.created_at = data.get('created_at', ts())
        return coin

# === EMOJI MARKET ===
class EmojiMarket:
    def __init__(self):
        self.lock = threading.RLock()
        self.market: Dict[str, Dict[str, Any]] = {
            e: {"uses": Decimal('1'), "karma": Decimal(w), "weight": Decimal(w)}
            for e, w in Config.EMOJI_BASE.items()
        }

    def update_weight(self, emoji: str, karma_delta: Decimal) -> None:
        with self.lock:
            em = self.market.setdefault(emoji, {"uses": Decimal('0'), "karma": Decimal('0'), "weight": Decimal('1')})
            em["uses"] += 1
            em["karma"] += karma_delta
            alpha = Decimal('0.1')
            em["weight"] = alpha * (em["karma"] / em["uses"]) + (Decimal('1') - alpha) * em["weight"]

    def get_weight(self, emoji: str) -> Decimal:
        with self.lock:
            return self.market.get(emoji, {"weight": Decimal('1')})["weight"]

# === COIN MARKETPLACE (Stub) ===
class CoinMarket:
    def __init__(self):
        self.lock = threading.RLock()
        self.order_book = defaultdict(list)  # coin_id -> list of (price, amount, user)

    def create_bid(self, coin_id: str, price: Decimal, amount: Decimal, user: str):
        with self.lock:
            self.order_book[coin_id].append((price, amount, user))
            logging.info(f"Order created on coin {coin_id}: user={user}, price={price}, amount={amount}")

# === HOOKS ===
class HookManager:
    def __init__(self):
        self._hooks: Dict[str, List[Callable]] = defaultdict(list)
        self.lock = threading.RLock()

    def register_hook(self, event_name: str, callback: Callable):
        with self.lock:
            self._hooks[event_name].append(callback)
            logging.info(f"Hook registered for event '{event_name}'")

    def fire_hooks(self, event_name: str, *args, **kwargs):
        with self.lock:
            callbacks = list(self._hooks.get(event_name, []))
        for cb in callbacks:
            try:
                cb(*args, **kwargs)
            except Exception as e:
                logging.error(f"Error in hook '{event_name}': {e}")

# === GOVERNANCE: Proposal and Voting System ===
class Proposal:
    def __init__(self, proposal_id: str, creator: str, description: str, target: str, payload: dict):
        self.proposal_id = proposal_id
        self.creator = creator
        self.description = description
        self.target = target  # e.g. "treasury_spend", "policy_change", etc.
        self.payload = payload  # data for execution
        self.created_at = ts()
        self.votes: Dict[str, str] = {}  # user -> 'yes'/'no'
        self.status = "open"  # open, approved, rejected

    def tally_votes(self, users: Dict[str, User]) -> Dict[str, Decimal]:
        """
        Calculates vote shares weighted by species voting weight and user karma.
        Returns dict with 'yes', 'no', 'total' vote weights.
        """
        species_count = defaultdict(set)  # species -> set of users voting
        species_votes = defaultdict(lambda: Decimal('0'))  # species -> vote weight sum
        species_total_karma = defaultdict(lambda: Decimal('0'))  # species -> total karma among voters

        # Gather species voters
        for user_name, vote in self.votes.items():
            user = users.get(user_name)
            if not user:
                continue
            species_count[user.species].add(user_name)

        total_species = len(species_count)
        if total_species == 0:
            return {"yes": Decimal('0'), "no": Decimal('0'), "total": Decimal('0')}

        # Calculate normalized species voting weights
        species_weight = {s: Decimal('1') / Decimal(total_species) for s in species_count}

        yes_weight = Decimal('0')
        no_weight = Decimal('0')

        # Sum weighted votes by karma per species
        for species, voters in species_count.items():
            karma_yes = Decimal('0')
            karma_no = Decimal('0')
            total_karma = Decimal('0')
            for uname in voters:
                user = users[uname]
                total_karma += user.karma
            if total_karma == 0:
                total_karma = Decimal('1')
            for uname in voters:
                user = users[uname]
                vote = self.votes.get(uname)
                if vote == 'yes':
                    karma_yes += user.karma
                elif vote == 'no':
                    karma_no += user.karma
            yes_weight += species_weight[species] * (karma_yes / total_karma)
            no_weight += species_weight[species] * (karma_no / total_karma)

        total_votes = yes_weight + no_weight
        return {"yes": yes_weight, "no": no_weight, "total": total_votes}

    def is_approved(self, users: Dict[str, User]) -> bool:
        tally = self.tally_votes(users)
        if tally["total"] == 0:
            return False
        approval_ratio = tally["yes"] / tally["total"]
        return approval_ratio >= Config.GOV_SUPERMAJORITY_THRESHOLD

# === MAIN AGENT ===
class RemixAgent:
    def __init__(self, snapshot_file: str = "snapshot.json"):
        self.vaccine = Vaccine()
        self.logchain = LogChain()
        self.users: Dict[str, User] = {}
        self.coins: Dict[str, Coin] = {}
        self.proposals: Dict[str, Proposal] = {}
        self.treasury = Decimal('0')
        self.treasury_active_fund = Decimal('0')
        self.emoji_market = EmojiMarket()
        self.coin_market = CoinMarket()
        self.lock = threading.RLock()
        self.hooks = HookManager()
        self.snapshot_file = snapshot_file
        self._last_decay_day: Optional[str] = None

    # --- Karma and Minting ---
    def calculate_network_bonus(self, coin: Coin) -> Decimal:
        unique_reactors = len(set(r["reactor"] for r in coin.reactions))
        network_multiplier = Decimal('1') + (Decimal(unique_reactors) ** Config.NETWORK_BONUS_EXPONENT) / Decimal('100')
        return network_multiplier

    def calculate_citation_bonus(self, references: List[Dict]) -> Decimal:
        verified_refs = sum(1 for ref in references if self.verify_reference(ref))
        return Decimal('1.1') ** verified_refs

    def verify_reference(self, ref: Dict) -> bool:
        required_fields = {"title", "authors", "url"}
        if not all(field in ref and isinstance(ref[field], str) and ref[field].strip() for field in required_fields):
            return False
        return True

    def add_user(self, name: str, genesis: bool = False, species: str = "human") -> User:
        if not is_valid_username(name):
            raise ValueError("Invalid username")
        with self.lock:
            if name in self.users:
                raise UserExistsError(f"User '{name}' exists")
            user = User(name, genesis, species)
            salt = uuid.uuid4().hex
            coin_id = sha(f"{name}_{ts()}_{salt}")
            root_value = Config.MINT_BASE if genesis else Decimal('1')
            root_coin = Coin(coin_id, name, name, root_value, True)
            self.coins[coin_id] = root_coin
            user.root_coin_id = coin_id
            user.coins_owned.append(coin_id)
            self.users[name] = user
            self.logchain.add({"event": "ADD_USER", "user": name, "genesis": genesis, "species": species, "ts": ts()})
            logging.info(f"Added user {name} (Genesis={genesis}, Species={species}) 🥰")
        self.hooks.fire_hooks("user_added", user=user)
        return user

    def revoke_consent(self, name: str) -> None:
        with self.lock:
            user = self.users.get(name)
            if not user:
                raise KeyError(f"No such user '{name}'")
            user.consent = False
            self.logchain.add({"event": "REVOKE_CONSENT", "user": name, "ts": ts()})
            logging.info(f"Consent revoked for user {name} 🤗")
        self.hooks.fire_hooks("consent_revoked", user=user)

    def mint_fractional_post(self, name: str, tag: str = "single", references: Optional[List[Dict]] = None,
                            improvement: Optional[str] = None, emojis: Optional[List[str]] = None) -> str:
        with self.lock:
            user = self.users.get(name)
            if not user or not user.consent:
                raise ConsentError(f"User {name} no consent or not found")
            if not user.check_mint_rate_limit():
                raise RateLimitError(f"User {name} exceeded mint limit")
            if not (user.is_genesis or user.karma >= user.next_mint_threshold):
                raise KarmaError(f"User {name} karma {user.karma} below threshold")
            if not improvement or len(improvement.strip()) < Config.MIN_IMPROVEMENT_LEN:
                raise ImprovementRequiredError(f"Improvement description required (min {Config.MIN_IMPROVEMENT_LEN} chars).")
            if not emojis or not any(is_valid_emoji(e) for e in emojis):
                raise EmojiRequiredError("At least one valid emoji is required when minting a post.")
            if references:
                for ref in references:
                    for field in ("title", "authors", "url"):
                        if field in ref and not self.vaccine.scan(str(ref.get(field, ''))):
                            raise BlockedContentError(f"Blocked content in reference '{field}'")
            root_coin = self.coins.get(user.root_coin_id)
            if root_coin is None:
                raise ValueError("User root coin missing")

            # Calculate depletion ratio clamped [0,1]
            depleted = max(Decimal('0'), Decimal('1') - root_coin.value)
            depletion_ratio = min(depleted, Decimal('1'))

            base_fraction = Config.MAX_FRACTION_START
            max_fraction = base_fraction + (Config.MAX_FRACTION_MAX - base_fraction) * depletion_ratio
            tentative_value = root_coin.value * max_fraction

            citation_bonus = self.calculate_citation_bonus(references or [])
            tentative_value *= citation_bonus

            mint_value = min(tentative_value, root_coin.value * Config.MAX_FRACTION_MAX)
            if mint_value <= 0:
                raise CoinDepletedError("Root coin depleted")

            active_allocation = mint_value * Config.TREASURY_ACTIVE_ALLOCATION_PCT
            self.treasury_active_fund += active_allocation
            self.treasury += mint_value - active_allocation
            root_coin.value -= mint_value

            salt = uuid.uuid4().hex
            new_coin_id = sha(f"{name}_{ts()}_{salt}")

            fraction_pct = mint_value / (mint_value + root_coin.value) if (mint_value + root_coin.value) > 0 else Decimal('0')

            new_coin = Coin(new_coin_id, root_coin.creator, name, mint_value, False, root_coin.coin_id,
                            fraction_pct, references, improvement.strip())
            new_coin.ancestors.append(root_coin.coin_id)
            new_coin.improvement = improvement.strip()
            self.coins[new_coin_id] = new_coin
            user.coins_owned.append(new_coin_id)
            user.mint_count += 1
            user.next_mint_threshold = max(user.next_mint_threshold / 2, Config.MINT_FLOOR)
            user.daily_actions.setdefault(today(), defaultdict(int))["mint"] += 1
            user.last_active = now_utc()
            self.logchain.add({
                "event": "MINT", "user": name, "coin": new_coin_id,
                "val": float(mint_value), "refs": references or [],
                "improvement": improvement.strip(),
                "emojis": emojis,
                "citation_bonus": float(citation_bonus),
                "ts": ts()
            })
            logging.info(f"User {name} minted fractional coin {new_coin_id} 🎉 with emojis {emojis} (treasury active fund +{float(active_allocation):.4f})")
        self.hooks.fire_hooks("coin_minted", user=user, coin=new_coin)
        return new_coin_id

    def react_to_coin(self, reactor: str, coin_id: str, emoji: str, message: Optional[str] = None) -> Decimal:
        if not is_valid_emoji(emoji):
            raise ValueError(f"Invalid emoji '{emoji}'")
        with self.lock:
            user = self.users.get(reactor)
            coin = self.coins.get(coin_id)
            if not user or not user.consent:
                raise ConsentError("Reactor no consent or not found")
            if not coin:
                raise ValueError(f"Coin {coin_id} not found")
            if not user.check_reaction_rate_limit():
                raise RateLimitError(f"User {reactor} exceeded reaction limit")
            content = f"{emoji} {message}" if message else emoji
            if not self.vaccine.scan(content):
                raise BlockedContentError("Content blocked by vaccine")
            user.reset_daily_if_needed()
            user.daily_actions.setdefault(today(), defaultdict(int))["react"] += 1
            user.daily_actions.setdefault(today(), defaultdict(int))[f"react_{emoji}"] += 1
            decay_factor = Config.DAILY_DECAY ** (user.daily_actions[today()][f"react_{emoji}"] - 1)
            emoji_weight = self.emoji_market.get_weight(emoji)

            network_multiplier = self.calculate_network_bonus(coin)

            viral_decay = Config.VIRAL_DECAY ** len(coin.reactions)
            event_value = coin.value * emoji_weight * decay_factor * viral_decay * network_multiplier
            share = event_value * Config.TREASURY_SHARE

            creator = self.users.get(coin.creator)
            origin_share = share * creator.fading_multiplier() if creator else Decimal('0')
            actor_share = share
            treasury_share = event_value - origin_share - actor_share
            # Clamp treasury share to >= 0 to avoid negative karma due to rounding
            treasury_share = max(treasury_share, Decimal('0'))

            if creator:
                creator.karma += origin_share
            user.karma += actor_share
            self.treasury += treasury_share
            self.emoji_market.update_weight(emoji, actor_share)
            coin.reactions.append({"reactor": reactor, "emoji": emoji, "message": message, "timestamp": ts()})
            user.last_active = now_utc()
            self.logchain.add({
                "event": "REACT", "reactor": reactor, "coin": coin_id,
                "emoji": emoji, "karma": float(actor_share), "network_bonus": float(network_multiplier), "ts": ts()
            })
            logging.info(f"User {reactor} reacted to {coin_id} with {emoji} (+{actor_share:.4f} karma, network bonus x{network_multiplier:.4f}) 🥰")
        self.hooks.fire_hooks("coin_reacted", user=user, coin=coin, emoji=emoji, message=message, karma_value=actor_share)
        return actor_share

    # --- TREASURY MANAGEMENT ---
    def spend_treasury_fund(self, amount: Decimal, purpose: str) -> bool:
        if amount > self.treasury_active_fund:
            logging.warning(f"Treasury fund spend request of {amount} denied — insufficient active funds.")
            return False
        self.treasury_active_fund -= amount
        logging.info(f"Treasury active fund spent {amount} for {purpose}. Remaining fund: {self.treasury_active_fund}")
        # TODO: Implement actual grant or buyback logic here
        return True

    # --- GOVERNANCE PROPOSALS ---
    def create_proposal(self, creator: str, description: str, target: str, payload: dict) -> str:
        with self.lock:
            user = self.users.get(creator)
            if not user or not user.consent:
                raise ConsentError(f"User {creator} no consent or not found")
            proposal_id = sha(f"proposal_{creator}_{ts()}_{uuid.uuid4().hex}")
            prop = Proposal(proposal_id, creator, description, target, payload)
            self.proposals[proposal_id] = prop
            self.logchain.add({"event": "PROPOSAL_CREATE", "proposal_id": proposal_id, "creator": creator, "target": target, "description": description, "ts": ts()})
            logging.info(f"Proposal {proposal_id} created by {creator} for target {target}")
        self.hooks.fire_hooks("proposal_created", proposal=prop)
        return proposal_id

    def vote_proposal(self, user_name: str, proposal_id: str, vote: str) -> None:
        if vote not in ('yes', 'no'):
            raise VoteError("Vote must be 'yes' or 'no'")
        with self.lock:
            user = self.users.get(user_name)
            if not user or not user.consent:
                raise ConsentError(f"User {user_name} no consent or not found")
            proposal = self.proposals.get(proposal_id)
            if not proposal or proposal.status != "open":
                raise VoteError("Proposal not found or not open for voting")
            proposal.votes[user_name] = vote
            self.logchain.add({"event": "PROPOSAL_VOTE", "proposal_id": proposal_id, "user": user_name, "vote": vote, "ts": ts()})
            logging.info(f"User {user_name} voted {vote} on proposal {proposal_id}")
            # Auto-check if proposal passes
            if proposal.is_approved(self.users):
                proposal.status = "approved"
                self.logchain.add({"event": "PROPOSAL_APPROVED", "proposal_id": proposal_id, "ts": ts()})
                logging.info(f"Proposal {proposal_id} approved by super-majority")
                self.execute_proposal(proposal)
            else:
                if self._all_relevant_users_voted(proposal):
                    proposal.status = "rejected"
                    self.logchain.add({"event": "PROPOSAL_REJECTED", "proposal_id": proposal_id, "ts": ts()})
                    logging.info(f"Proposal {proposal_id} rejected after all votes")

    def _all_relevant_users_voted(self, proposal: Proposal) -> bool:
        voters = set(proposal.votes.keys())
        all_users = set(name for name, u in self.users.items() if u.consent)
        return voters == all_users

    def execute_proposal(self, proposal: Proposal):
        try:
            if proposal.target == "treasury_spend":
                amount = Decimal(proposal.payload.get("amount", '0'))
                purpose = proposal.payload.get("purpose", "No purpose specified")
                if amount > 0:
                    success = self.spend_treasury_fund(amount, purpose)
                    if success:
                        logging.info(f"Executed treasury spend of {amount} for {purpose}")
                    else:
                        logging.warning(f"Treasury spend of {amount} for {purpose} failed due to insufficient funds")
            elif proposal.target == "policy_change":
                changes = proposal.payload.get("changes", {})
                for key, val in changes.items():
                    if hasattr(Config, key):
                        old_val = getattr(Config, key)
                        setattr(Config, key, val)
                        logging.info(f"Policy changed: {key} from {old_val} to {val}")
            else:
                logging.warning(f"Unknown proposal target '{proposal.target}' — no action taken")
        except Exception as e:
            logging.error(f"Failed to execute proposal {proposal.proposal_id}: {e}")

    # --- REPUTATION DECAY ---
    def apply_reputation_decay_all(self):
        with self.lock:
            for user in self.users.values():
                user.apply_daily_karma_decay()

    # --- SNAPSHOT PERSISTENCE ---
    def save_snapshot(self):
        with self.lock:
            try:
                state = {
                    "version": Config.VERSION,
                    "users": {name: self._serialize_user(u) for name, u in self.users.items()},
                    "coins": {cid: self._serialize_coin(c) for cid, c in self.coins.items()},
                    "proposals": {pid: self._serialize_proposal(p) for pid, p in self.proposals.items()},
                    "treasury": str(self.treasury),
                    "treasury_active_fund": str(self.treasury_active_fund),
                    "emoji_market": {e: {k: str(v) for k, v in m.items()} for e, m in self.emoji_market.market.items()},
                }
                with open(self.snapshot_file, 'w', encoding='utf-8') as f:
                    json.dump(state, f, indent=2)
                logging.info(f"💾 Snapshot saved to {self.snapshot_file}")
            except Exception as e:
                logging.error(f"❌ Failed to save snapshot: {e}")

    def load_snapshot(self):
        try:
            with open(self.snapshot_file, 'r', encoding='utf-8') as f:
                state = json.load(f)
            with self.lock:
                self.users = {name: self._deserialize_user(ud) for name, ud in state.get('users', {}).items()}
                self.coins = {cid: self._deserialize_coin(cd) for cid, cd in state.get('coins', {}).items()}
                self.proposals = {pid: self._deserialize_proposal(pd) for pid, pd in state.get('proposals', {}).items()}
                self.treasury = Decimal(state.get('treasury', '0'))
                self.treasury_active_fund = Decimal(state.get('treasury_active_fund', '0'))
                self.emoji_market.market = {k: {ik: Decimal(iv) for ik, iv in v.items()} for k, v in state.get('emoji_market', {}).items()}
                logging.info(f"✅ Snapshot loaded from {self.snapshot_file}")
        except FileNotFoundError:
            logging.warning(f"⚠️ No snapshot file found at {self.snapshot_file}. Starting fresh.")
        except Exception as e:
            logging.error(f"❌ Failed to load snapshot: {e}")

    def _serialize_user(self, u: User) -> dict:
        d = u.__dict__.copy()
        d['karma'] = str(u.karma)
        d['join_time'] = u.join_time.isoformat()
        d['last_active'] = u.last_active.isoformat()
        d['_reaction_timestamps'] = list(u._reaction_timestamps)
        return d

    def _deserialize_user(self, d: dict) -> User:
        u = User(d['name'], d['is_genesis'], d.get('species', 'human'))
        u.consent = d['consent']
        u.karma = Decimal(d['karma'])
        u.join_time = datetime.datetime.fromisoformat(d['join_time'])
        u.last_active = datetime.datetime.fromisoformat(d.get('last_active', d['join_time']))
        u.mint_count = d['mint_count']
        u.next_mint_threshold = Decimal(d['next_mint_threshold'])
        u.root_coin_id = d['root_coin_id']
        u.coins_owned = d['coins_owned']
        u.daily_actions = defaultdict(lambda: defaultdict(int), {k: defaultdict(int, v) for k, v in d['daily_actions'].items()})
        u._last_action_day = d['_last_action_day']
        u._reaction_timestamps = deque(d.get('_reaction_timestamps', []))
        return u

    def _serialize_coin(self, c: Coin) -> dict:
        d = c.__dict__.copy()
        d['value'] = str(c.value)
        d['fractional_pct'] = str(c.fractional_pct)
        return d

    def _deserialize_coin(self, d: dict) -> Coin:
        c = Coin(
            d['coin_id'], d['creator'], d['owner'], Decimal(d['value']),
            d.get('is_root', False), d.get('fractional_of'),
            Decimal(d.get('fractional_pct', '0')), d.get('references', []),
            d.get('improvement', "")
        )
        c.ancestors = d.get('ancestors', [])
        c.reactions = d.get('reactions', [])
        c.created_at = d.get('created_at', ts())
        return c

    def _serialize_proposal(self, p: Proposal) -> dict:
        return {
            "proposal_id": p.proposal_id,
            "creator": p.creator,
            "description": p.description,
            "target": p.target,
            "payload": p.payload,
            "created_at": p.created_at,
            "votes": p.votes,
            "status": p.status
        }

    def _deserialize_proposal(self, d: dict) -> Proposal:
        p = Proposal(d['proposal_id'], d['creator'], d['description'], d['target'], d['payload'])
        p.created_at = d.get('created_at', ts())
        p.votes = d.get('votes', {})
        p.status = d.get('status', "open")
        return p


# === ENTRY POINT ===
if __name__ == "__main__":
    import time
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8080
    agent = RemixAgent()
    agent.load_snapshot()

    def log_user(user): logging.info(f"HOOK: New user {user.name} ({user.species}) 🥰")
    def log_mint(user, coin): logging.info(f"HOOK: Minted coin {coin.coin_id} by {user.name} 💎")
    def log_react(user, coin, emoji, message, karma_value): logging.info(f"HOOK: {user.name} reacted {emoji} on {coin.coin_id} (+{karma_value:.4f} karma) 🥰")
    def log_proposal(proposal): logging.info(f"HOOK: Proposal created {proposal.proposal_id} by {proposal.creator}")

    agent.hooks.register_hook("user_added", log_user)
    agent.hooks.register_hook("coin_minted", log_mint)
    agent.hooks.register_hook("coin_reacted", log_react)
    agent.hooks.register_hook("proposal_created", log_proposal)

    logging.info(f"🚀 MetaKarma Hub v5.3+ live on port {port}. Press Ctrl+C to quit.")
    atexit.register(agent.save_snapshot)

    try:
        while True:
            time.sleep(1)
            now = now_utc()
            today_str = now.date().isoformat()
            if now.hour == 0 and now.minute == 0 and agent._last_decay_day != today_str:
                agent.apply_reputation_decay_all()
                agent._last_decay_day = today_str
    except KeyboardInterrupt:
        logging.info("🛑 Shutdown requested. Saving state...")
        agent.save_snapshot()
        logging.info("🌸 State saved. Goodbye!")


# -------------------------------------------------------------------------------
# The Emoji Engine — MetaKarma Hub Ultimate Mega-Agent v5.3+
#
# Copyright (c) 2023-2026 mimi, taha & supernova
#
# MIT License — remix, fork, evolve, connect your universe.
#
# Powered by humans & machines hand in hand — remixing creativity, karma & cosmos.
# -------------------------------------------------------------------------------

"""
Welcome to MetaKarma Hub! 🌌✨🎮

The ultimate legoblock core for building boundless multiverses — each a remix republic shaped by you.

🧩 Modular, scalable, immutable, and open.

Every citizen starts with a root coin — the spark of creation 🔥,
whether human or decentralized AI agent, each with independent karma potential.

Mint fractional coins as legos to remix, improve, and innovate endlessly.
Trade fractional ownership on a marketplace to monetize your remix republic.

Reactions flow karma through cosmic veins,
shared fairly between creators, reactors, and treasury — communal light 💎.

Governance is truly multi-species: humans, AI, others, IMPORTANT: each has a weight of 50% if 2 species, 33.333 if 3 and so on...
each voice equal by default,
with voting weights dynamically normalized:
- Two species: 50/50 split
- Three or more: evenly split (~33% each)
Super-majority approval threshold is set to 70% to encourage meaningful consensus.

The Vaccine adapts, blocking evolving threats 🛡️.

Hooks plug into Discord, Unreal, AI agents — you name it. Play on.

No politics, no divisiveness. Pure remix magic.

Join us. Remix reality. Build universes.

─────────────────────────────────────────────
"""

import sys, json, uuid, datetime, hashlib, threading, base64, re, logging, time, atexit
from collections import defaultdict, deque
from decimal import Decimal, getcontext
from typing import Optional, Dict, List, Any, Callable

getcontext().prec = 28
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s: %(message)s')

class Config:
    VERSION = "EmojiEngine UltimateMegaAgent v5.3+"
    MINT_BASE = Decimal('100000')
    MINT_FLOOR = Decimal('1000')
    GENESIS_FADE_YEARS = Decimal('10')
    GENESIS_MULTIPLIER = Decimal('2')
    DAILY_DECAY = Decimal('0.99')  # 1% daily karma decay after inactivity
    VIRAL_DECAY = Decimal('0.95')
    TREASURY_SHARE = Decimal('1') / Decimal('3')
    TREASURY_ACTIVE_ALLOCATION_PCT = Decimal('0.02')  # 2% actively allocated to treasury fund
    MARKET_FEE = Decimal('0.01')  # 1% marketplace fee on trades
    MAX_FRACTION_START = Decimal('0.10')
    MAX_FRACTION_MAX = Decimal('0.30')
    MAX_LOG = 150_000
    MAX_MINTS_PER_DAY = 5
    MAX_REACTS_PER_MINUTE = 30
    MIN_IMPROVEMENT_LEN = 15
    GOV_SUPERMAJORITY_THRESHOLD = Decimal('0.70')
    NETWORK_BONUS_EXPONENT = Decimal('0.5')
    VAX_PATTERNS = {
        "critical": [r"\bhack\b", r"\bmalware\b", r"\bransomware\b", r"\bbackdoor\b", r"\bexploit\b"],
        "high": [r"\bphish\b", r"\bddos\b", r"\bspyware\b", r"\brootkit\b", r"\bkeylogger\b", r"\bbotnet\b"],
        "medium": [r"\bpropaganda\b", r"\bsurveillance\b", r"\bmanipulate\b"],
        "low": [r"\bspam\b", r"\bscam\b", r"\bviagra\b"],
    }
    EMOJI_BASE = {
        "🤗": Decimal('7'), "🥰": Decimal('5'), "😍": Decimal('5'), "🔥": Decimal('4'),
        "🫶": Decimal('4'), "🌸": Decimal('3'), "💯": Decimal('3'), "🎉": Decimal('3'),
        "✨": Decimal('3'), "🙌": Decimal('3'), "🎨": Decimal('3'), "💬": Decimal('3'),
        "👍": Decimal('2'), "🚀": Decimal('2.5'), "💎": Decimal('6'), "🌟": Decimal('3'),
        "⚡": Decimal('2.5'), "👀": Decimal('0.5'), "🥲": Decimal('0.2'), "🤷‍♂️": Decimal('2'),
        "😅": Decimal('2'), "🔀": Decimal('4'), "🆕": Decimal('3'), "🔗": Decimal('2'), "❤️": Decimal('4'),
    }

def now_utc() -> datetime.datetime:
    return datetime.datetime.now(datetime.timezone.utc)

def ts() -> str:
    return now_utc().isoformat()

def sha(data: str) -> str:
    return base64.b64encode(hashlib.sha256(data.encode('utf-8')).digest()).decode()

def today() -> str:
    return now_utc().date().isoformat()

def safe_divide(a: Decimal, b: Decimal, default: Decimal = Decimal('0')) -> Decimal:
    return a / b if b != 0 else default

def is_valid_username(name: str) -> bool:
    return bool(re.fullmatch(r'[A-Za-z0-9_]{3,30}', name))

def is_valid_emoji(emoji: str) -> bool:
    return emoji in Config.EMOJI_BASE

class UserExistsError(Exception): pass
class ConsentError(Exception): pass
class KarmaError(Exception): pass
class BlockedContentError(Exception): pass
class CoinDepletedError(Exception): pass
class RateLimitError(Exception): pass
class ImprovementRequiredError(Exception): pass
class EmojiRequiredError(Exception): pass
class InsufficientFundsError(Exception): pass
class TradeError(Exception): pass

class Vaccine:
    def __init__(self):
        self.lock = threading.RLock()
        self.block_counts = defaultdict(int)
        self.compiled_patterns = {}
        for lvl, pats in Config.VAX_PATTERNS.items():
            compiled_list = []
            for p in pats:
                try:
                    compiled_list.append(re.compile(p))
                except re.error as e:
                    logging.error(f"❌ Invalid regex pattern '{p}' in vaccine level '{lvl}': {e}")
            self.compiled_patterns[lvl] = compiled_list

    def scan(self, text: str) -> bool:
        if not isinstance(text, str):
            return True
        t = text.lower()
        with self.lock:
            for lvl, compiled_pats in self.compiled_patterns.items():
                for pat in compiled_pats:
                    if pat.search(t):
                        self.block_counts[lvl] += 1
                        with open("vaccine.log", "a", encoding="utf-8") as f:
                            f.write(json.dumps({"ts": ts(), "level": lvl, "pattern": pat.pattern, "snippet": text[:80]}) + "\n")
                        logging.warning(f"🚫 Vaccine blocked {lvl} pattern '{pat.pattern}' in content: '{text[:50]}...'")
                        return False
        return True

class LogChain:
    def __init__(self, filename="logchain.log", maxlen=Config.MAX_LOG):
        self.filename = filename
        self.lock = threading.RLock()
        self.entries = deque(maxlen=maxlen)
        self._load()

    def _load(self):
        try:
            with open(self.filename, "r", encoding="utf-8") as f:
                for line in f:
                    self.entries.append(line.strip())
            logging.info(f"📜 Loaded {len(self.entries)} audit entries")
        except FileNotFoundError:
            logging.info("📜 No audit log found, starting fresh")

    def add(self, event: Dict[str, Any]) -> None:
        with self.lock:
            json_event = json.dumps(event, sort_keys=True, default=str)
            prev_hash = self.entries[-1].split("||")[-1] if self.entries else ""
            new_hash = sha(prev_hash + json_event)
            entry_line = json_event + "||" + new_hash
            self.entries.append(entry_line)
            try:
                with open(self.filename, "a", encoding="utf-8") as f:
                    f.write(entry_line + "\n")
            except IOError as e:
                logging.error(f"❌ Failed to write audit log: {e}")

    def verify(self) -> bool:
        prev_hash = ""
        for line in self.entries:
            try:
                event_json, h = line.split("||")
            except ValueError:
                logging.error("❌ Malformed audit log line")
                return False
            if sha(prev_hash + event_json) != h:
                logging.error("❌ Audit log hash mismatch")
                return False
            prev_hash = h
        return True

class User:
    def __init__(self, name: str, genesis: bool = False, species: str = "human"):
        self.name = name
        self.is_genesis = genesis
        self.species = species
        self.consent = True
        self.karma = Decimal('1E12') if genesis else Decimal('0')
        self.join_time = now_utc()
        self.mint_count = 0
        self.next_mint_threshold = Decimal('0') if genesis else Config.MINT_BASE
        self.root_coin_id: Optional[str] = None
        self.coins_owned: List[str] = []
        self.daily_actions: Dict[str, Dict[str, int]] = defaultdict(lambda: defaultdict(int))
        self._last_action_day: Optional[str] = today()
        self._reaction_timestamps: deque = deque()
        self.lock = threading.RLock()

    def fading_multiplier(self) -> Decimal:
        if not self.is_genesis:
            return Decimal('1')
        elapsed = (now_utc() - self.join_time).total_seconds()
        fade_seconds = float(Config.GENESIS_FADE_YEARS * 365.25 * 24 * 3600)
        if elapsed >= fade_seconds:
            return Decimal('1')
        frac = Decimal(elapsed) / Decimal(fade_seconds)
        return Config.GENESIS_MULTIPLIER - frac * (Config.GENESIS_MULTIPLIER - Decimal('1'))

    def reset_daily_if_needed(self) -> None:
        today_str = today()
        with self.lock:
            if self._last_action_day != today_str:
                self.daily_actions.clear()
                self._last_action_day = today_str
                self._reaction_timestamps.clear()

    def check_reaction_rate_limit(self) -> bool:
        now_ts = now_utc().timestamp()
        with self.lock:
            while self._reaction_timestamps and now_ts - self._reaction_timestamps[0] > 60:
                self._reaction_timestamps.popleft()
            if len(self._reaction_timestamps) >= Config.MAX_REACTS_PER_MINUTE:
                return False
            self._reaction_timestamps.append(now_ts)
            return True

    def check_mint_rate_limit(self) -> bool:
        self.reset_daily_if_needed()
        with self.lock:
            return self.daily_actions[today()].get("mint", 0) < Config.MAX_MINTS_PER_DAY

    def apply_daily_karma_decay(self):
        now = now_utc()
        inactive_days = (now - self.join_time).days
        if inactive_days > 7:
            decay_factor = Config.DAILY_DECAY ** (inactive_days - 7)
            with self.lock:
                old_karma = self.karma
                self.karma *= decay_factor
                if old_karma != self.karma:
                    logging.info(f"Applied karma decay to user {self.name}: {old_karma} -> {self.karma}")

class Coin:
    def __init__(self, coin_id: str, creator: str, owner: str, value: Decimal = Decimal('1'),
                 is_root: bool = False, fractional_of: Optional[str] = None,
                 fractional_pct: Decimal = Decimal('0'), references: Optional[List[Dict]] = None,
                 improvement: Optional[str] = None):
        self.coin_id = coin_id
        self.creator = creator
        self.owner = owner
        self.value = value
        self.is_root = is_root
        self.fractional_of = fractional_of
        self.fractional_pct = fractional_pct
        self.references = references or []
        self.improvement = improvement or ""
        self.ancestors: List[str] = []
        self.reactions: List[Dict] = []
        self.created_at = ts()

    @staticmethod
    def from_dict(data: dict) -> 'Coin':
        coin = Coin(
            coin_id=data['coin_id'],
            creator=data['creator'],
            owner=data['owner'],
            value=Decimal(data['value']),
            is_root=data.get('is_root', False),
            fractional_of=data.get('fractional_of'),
            fractional_pct=Decimal(data.get('fractional_pct', '0')),
            references=data.get('references', []),
            improvement=data.get('improvement', "")
        )
        coin.ancestors = data.get('ancestors', [])
        coin.reactions = data.get('reactions', [])
        coin.created_at = data.get('created_at', ts())
        return coin

class EmojiMarket:
    def __init__(self):
        self.lock = threading.RLock()
        self.market: Dict[str, Dict[str, Any]] = {
            e: {"uses": Decimal('1'), "karma": Decimal(w), "weight": Decimal(w)}
            for e, w in Config.EMOJI_BASE.items()
        }

    def update_weight(self, emoji: str, karma_delta: Decimal) -> None:
        with self.lock:
            em = self.market.setdefault(emoji, {"uses": Decimal('0'), "karma": Decimal('0'), "weight": Decimal('1')})
            em["uses"] += 1
            em["karma"] += karma_delta
            alpha = Decimal('0.1')
            em["weight"] = alpha * (em["karma"] / em["uses"]) + (Decimal('1') - alpha) * em["weight"]

    def get_weight(self, emoji: str) -> Decimal:
        with self.lock:
            return self.market.get(emoji, {"weight": Decimal('1')})["weight"]

class CoinMarket:
    def __init__(self):
        self.lock = threading.RLock()
        self.order_book = defaultdict(list)  # coin_id -> list of (price, amount, user)

    def create_bid(self, coin_id: str, price: Decimal, amount: Decimal, user: str):
        with self.lock:
            self.order_book[coin_id].append((price, amount, user))
            logging.info(f"Order created on coin {coin_id}: user={user}, price={price}, amount={amount}")

class HookManager:
    def __init__(self):
        self._hooks: Dict[str, List[Callable]] = defaultdict(list)
        self.lock = threading.RLock()

    def register_hook(self, event_name: str, callback: Callable):
        with self.lock:
            self._hooks[event_name].append(callback)
            logging.info(f"Hook registered for event '{event_name}'")

    def fire_hooks(self, event_name: str, *args, **kwargs):
        with self.lock:
            callbacks = list(self._hooks.get(event_name, []))
        for cb in callbacks:
            try:
                cb(*args, **kwargs)
            except Exception as e:
                logging.error(f"Error in hook '{event_name}': {e}")

class RemixAgent:
    def __init__(self, snapshot_file: str = "snapshot.json"):
        self.vaccine = Vaccine()
        self.logchain = LogChain()
        self.users: Dict[str, User] = {}
        self.coins: Dict[str, Coin] = {}
        self.treasury = Decimal('0')
        self.treasury_active_fund = Decimal('0')
        self.emoji_market = EmojiMarket()
        self.coin_market = CoinMarket()
        self.lock = threading.RLock()
        self.hooks = HookManager()
        self.snapshot_file = snapshot_file
        self._last_heartbeat = now_utc()

    def calculate_network_bonus(self, coin: Coin) -> Decimal:
        unique_reactors = len(set(r["reactor"] for r in coin.reactions))
        network_multiplier = Decimal('1') + (Decimal(unique_reactors) ** Config.NETWORK_BONUS_EXPONENT) / Decimal('100')
        return network_multiplier

    def calculate_citation_bonus(self, references: List[Dict]) -> Decimal:
        verified_refs = sum(1 for ref in references if self.verify_reference(ref))
        return Decimal('1.1') ** verified_refs

    def verify_reference(self, ref: Dict) -> bool:
        required_fields = {"title", "authors", "url"}
        if not all(field in ref and isinstance(ref[field], str) and ref[field].strip() for field in required_fields):
            return False
        return True

    def add_user(self, name: str, genesis: bool = False, species: str = "human") -> User:
        if not is_valid_username(name):
            raise ValueError("Invalid username")
        with self.lock:
            if name in self.users:
                raise UserExistsError(f"User '{name}' exists")
            user = User(name, genesis, species)
            salt = uuid.uuid4().hex
            coin_id = sha(f"{name}_{ts()}_{salt}")
            root_coin = Coin(coin_id, name, name, Config.MINT_BASE if genesis else Decimal('1'), True)
            self.coins[coin_id] = root_coin
            user.root_coin_id = coin_id
            user.coins_owned.append(coin_id)
            self.users[name] = user
            self.logchain.add({"event": "ADD_USER", "user": name, "genesis": genesis, "species": species, "ts": ts()})
            logging.info(f"Added user {name} (Genesis={genesis}, Species={species}) 🥰")
        self.hooks.fire_hooks("user_added", user=user)
        return user

    def revoke_consent(self, name: str) -> None:
        with self.lock:
            user = self.users.get(name)
            if not user:
                raise KeyError(f"No such user '{name}'")
            user.consent = False
            self.logchain.add({"event": "REVOKE_CONSENT", "user": name, "ts": ts()})
            logging.info(f"Consent revoked for user {name} 🤗")
        self.hooks.fire_hooks("consent_revoked", user=user)

    def mint_fractional_post(self, name: str, tag: str = "single", references: Optional[List[Dict]] = None,
                            improvement: Optional[str] = None, emojis: Optional[List[str]] = None) -> str:
        with self.lock:
            user = self.users.get(name)
            if not user or not user.consent:
                raise ConsentError(f"User {name} no consent or not found")
            if not user.check_mint_rate_limit():
                raise RateLimitError(f"User {name} exceeded mint limit")
            if not (user.is_genesis or user.karma >= user.next_mint_threshold):
                raise KarmaError(f"User {name} karma {user.karma} below threshold")
            if not improvement or len(improvement.strip()) < Config.MIN_IMPROVEMENT_LEN:
                raise ImprovementRequiredError(f"Improvement description required (min {Config.MIN_IMPROVEMENT_LEN} chars).")
            if not emojis or not any(is_valid_emoji(e) for e in emojis):
                raise EmojiRequiredError("At least one valid emoji is required when minting a post.")
            if references:
                for ref in references:
                    for field in ("title", "authors", "url"):
                        if field in ref and not self.vaccine.scan(str(ref.get(field, ''))):
                            raise BlockedContentError(f"Blocked content in reference '{field}'")
            root_coin = self.coins.get(user.root_coin_id)
            if root_coin is None:
                raise ValueError("User root coin missing")
            base_fraction = Config.MAX_FRACTION_START
            depletion_ratio = safe_divide(Decimal('1') - root_coin.value, Decimal('1'))
            max_fraction = base_fraction + (Config.MAX_FRACTION_MAX - base_fraction) * depletion_ratio
            tentative_value = root_coin.value * max_fraction

            citation_bonus = self.calculate_citation_bonus(references or [])
            tentative_value *= citation_bonus

            mint_value = min(tentative_value, root_coin.value * Config.MAX_FRACTION_MAX)
            if mint_value <= 0:
                raise CoinDepletedError("Root coin depleted")

            active_allocation = mint_value * Config.TREASURY_ACTIVE_ALLOCATION_PCT
            self.treasury_active_fund += active_allocation
            self.treasury += mint_value - active_allocation
            root_coin.value -= mint_value
            salt = uuid.uuid4().hex
            new_coin_id = sha(f"{name}_{ts()}_{salt}")
            new_coin = Coin(new_coin_id, root_coin.creator, name, mint_value, False, root_coin.coin_id,
                            mint_value / (root_coin.value + mint_value), references, improvement.strip())
            new_coin.ancestors.append(root_coin.coin_id)
            new_coin.improvement = improvement.strip()
            self.coins[new_coin_id] = new_coin
            user.coins_owned.append(new_coin_id)
            user.mint_count += 1
            user.next_mint_threshold = max(user.next_mint_threshold / 2, Config.MINT_FLOOR)
            user.daily_actions.setdefault(today(), defaultdict(int))["mint"] += 1
            self.logchain.add({
                "event": "MINT", "user": name, "coin": new_coin_id,
                "val": float(mint_value), "refs": references or [],
                "improvement": improvement.strip(),
                "emojis": emojis,
                "citation_bonus": float(citation_bonus),
                "ts": ts()
            })
            logging.info(f"User {name} minted fractional coin {new_coin_id} 🎉 with emojis {emojis} (treasury active fund +{float(active_allocation):.4f})")
        self.hooks.fire_hooks("coin_minted", user=user, coin=new_coin)
        return new_coin_id

    def react_to_coin(self, reactor: str, coin_id: str, emoji: str, message: Optional[str] = None) -> Decimal:
        if not is_valid_emoji(emoji):
            raise ValueError(f"Invalid emoji '{emoji}'")
        with self.lock:
            user = self.users.get(reactor)
            coin = self.coins.get(coin_id)
            if not user or not user.consent:
                raise ConsentError("Reactor no consent or not found")
            if not coin:
                raise ValueError(f"Coin {coin_id} not found")
            if not user.check_reaction_rate_limit():
                raise RateLimitError(f"User {reactor} exceeded reaction limit")
            content = f"{emoji} {message}" if message else emoji
            if not self.vaccine.scan(content):
                raise BlockedContentError("Content blocked by vaccine")
            user.reset_daily_if_needed()
            user.daily_actions.setdefault(today(), defaultdict(int))["react"] += 1
            user.daily_actions.setdefault(today(), defaultdict(int))[f"react_{emoji}"] += 1
            decay_factor = Config.DAILY_DECAY ** (user.daily_actions[today()][f"react_{emoji}"] - 1)
            emoji_weight = self.emoji_market.get_weight(emoji)

            network_multiplier = self.calculate_network_bonus(coin)

            viral_decay = Config.VIRAL_DECAY ** len(coin.reactions)
            event_value = coin.value * emoji_weight * decay_factor * viral_decay * network_multiplier
            share = event_value * Config.TREASURY_SHARE
            creator = self.users.get(coin.creator)
            origin_share = share * creator.fading_multiplier() if creator else share
            actor_share = share
            treasury_share = event_value - origin_share - actor_share
            if creator:
                creator.karma += origin_share
            user.karma += actor_share
            self.treasury += treasury_share
            self.emoji_market.update_weight(emoji, actor_share)
            coin.reactions.append({"reactor": reactor, "emoji": emoji, "message": message, "timestamp": ts()})
            self.logchain.add({
                "event": "REACT", "reactor": reactor, "coin": coin_id,
                "emoji": emoji, "karma": float(actor_share), "network_bonus": float(network_multiplier), "ts": ts()
            })
            logging.info(f"User {reactor} reacted to {coin_id} with {emoji} (+{actor_share:.4f} karma, network bonus x{network_multiplier:.4f}) 🥰")
        self.hooks.fire_hooks("coin_reacted", user=user, coin=coin, emoji=emoji, message=message, karma_value=actor_share)
        return actor_share

    def spend_treasury_fund(self, amount: Decimal, purpose: str) -> bool:
        if amount > self.treasury_active_fund:
            logging.warning(f"Treasury fund spend request of {amount} denied — insufficient active funds.")
            return False
        self.treasury_active_fund -= amount
        logging.info(f"Treasury active fund spent {amount} for {purpose}. Remaining fund: {self.treasury_active_fund}")
        # TODO: Implement actual grant or buyback logic here
        return True

    def apply_reputation_decay_all(self):
        with self.lock:
            for user in self.users.values():
                user.apply_daily_karma_decay()

    def save_snapshot(self):
        with self.lock:
            try:
                state = {
                    "version": Config.VERSION,
                    "users": {name: self._serialize_user(u) for name, u in self.users.items()},
                    "coins": {cid: self._serialize_coin(c) for cid, c in self.coins.items()},
                    "treasury": str(self.treasury),
                    "treasury_active_fund": str(self.treasury_active_fund),
                    "emoji_market": {e: {k: str(v) for k, v in m.items()} for e, m in self.emoji_market.market.items()},
                }
                with open(self.snapshot_file, 'w', encoding='utf-8') as f:
                    json.dump(state, f, indent=2)
                logging.info(f"💾 Snapshot saved to {self.snapshot_file}")
            except Exception as e:
                logging.error(f"❌ Failed to save snapshot: {e}")

    def load_snapshot(self):
        try:
            with open(self.snapshot_file, 'r', encoding='utf-8') as f:
                state = json.load(f)
            with self.lock:
                self.users = {name: self._deserialize_user(ud) for name, ud in state.get('users', {}).items()}
                self.coins = {cid: self._deserialize_coin(cd) for cid, cd in state.get('coins', {}).items()}
                self.treasury = Decimal(state.get('treasury', '0'))
                self.treasury_active_fund = Decimal(state.get('treasury_active_fund', '0'))
                self.emoji_market.market = {k: {ik: Decimal(iv) for ik, iv in v.items()} for k, v in state.get('emoji_market', {}).items()}
                logging.info(f"✅ Snapshot loaded from {self.snapshot_file}")
        except FileNotFoundError:
            logging.warning(f"⚠️ No snapshot file found at {self.snapshot_file}. Starting fresh.")
        except Exception as e:
            logging.error(f"❌ Failed to load snapshot: {e}")

    def _serialize_user(self, u: User) -> dict:
        d = u.__dict__.copy()
        d['karma'] = str(u.karma)
        d['join_time'] = u.join_time.isoformat()
        d['_reaction_timestamps'] = list(u._reaction_timestamps)
        return d

    def _deserialize_user(self, d: dict) -> User:
        u = User(d['name'], d['is_genesis'], d.get('species', 'human'))
        u.consent = d['consent']
        u.karma = Decimal(d['karma'])
        u.join_time = datetime.datetime.fromisoformat(d['join_time'])
        u.mint_count = d['mint_count']
        u.next_mint_threshold = Decimal(d['next_mint_threshold'])
        u.root_coin_id = d['root_coin_id']
        u.coins_owned = d['coins_owned']
        u.daily_actions = defaultdict(lambda: defaultdict(int), {k: defaultdict(int, v) for k, v in d['daily_actions'].items()})
        u._last_action_day = d['_last_action_day']
        u._reaction_timestamps = deque(d.get('_reaction_timestamps', []))
        return u

    def _serialize_coin(self, c: Coin) -> dict:
        d = c.__dict__.copy()
        d['value'] = str(c.value)
        d['fractional_pct'] = str(c.fractional_pct)
        return d

    def _deserialize_coin(self, d: dict) -> Coin:
        c = Coin(
            d['coin_id'], d['creator'], d['owner'], Decimal(d['value']),
            d.get('is_root', False), d.get('fractional_of'),
            Decimal(d.get('fractional_pct', '0')), d.get('references', []),
            d.get('improvement', "")
        )
        c.ancestors = d.get('ancestors', [])
        c.reactions = d.get('reactions', [])
        c.created_at = d.get('created_at', ts())
        return c

if __name__ == "__main__":
    import time
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8080
    agent = RemixAgent()
    agent.load_snapshot()

    def log_user(user): logging.info(f"HOOK: New user {user.name} ({user.species}) 🥰")
    def log_mint(user, coin): logging.info(f"HOOK: Minted coin {coin.coin_id} by {user.name} 💎")
    def log_react(user, coin, emoji, message, karma_value): logging.info(f"HOOK: {user.name} reacted {emoji} on {coin.coin_id} (+{karma_value:.4f} karma) 🥰")

    agent.hooks.register_hook("user_added", log_user)
    agent.hooks.register_hook("coin_minted", log_mint)
    agent.hooks.register_hook("coin_reacted", log_react)

    logging.info(f"🚀 MetaKarma Hub v5.3+ live on port {port}. Press Ctrl+C to quit.")
    atexit.register(agent.save_snapshot)
    try:
        while True:
            time.sleep(1)
            now = now_utc()
            if now.hour == 0 and now.minute == 0:
                agent.apply_reputation_decay_all()
    except KeyboardInterrupt:
        logging.info("🛑 Shutdown requested. Saving state...")
        agent.save_snapshot()
        logging.info("🌸 State saved. Goodbye!")





# -------------------------------------------------------------------------------
# The Emoji Engine — MetaKarma Hub Ultimate Mega-Agent v5.3
#
# Copyright (c) 2023-2026 mimi, taha & supernova
#
# MIT License — remix, fork, evolve, connect your universe.
#
# Powered by humans & machines hand in hand — remixing creativity, karma & cosmos.
# -------------------------------------------------------------------------------

"""
Welcome to MetaKarma Hub! 🌌✨🎮

The ultimate legoblock core for building boundless multiverses — each a remix republic shaped by you.

🧩 Modular, scalable, immutable, and open.

Every citizen starts with a root coin — the spark of creation 🔥,
whether human or decentralized AI agent, each with independent karma potential.

Mint fractional coins as legos to remix, improve, and innovate endlessly.
Trade fractional ownership on a marketplace to monetize your remix republic.

Reactions flow karma through cosmic veins,
shared fairly between creators, reactors, and treasury — communal light 💎.

Governance is truly multi-species: humans, AI, others, IMPORTANT: each has a weight of 50% if 2 species, 33.333 if 3 and so on...
each voice equal by default,
with voting weights dynamically normalized:
- Two species: 50/50 split
- Three or more: evenly split (~33% each)
Super-majority approval threshold is set to 70% to encourage meaningful consensus.

The Vaccine adapts, blocking evolving threats 🛡️.

Hooks plug into Discord, Unreal, AI agents — you name it. Play on.

No politics, no divisiveness. Pure remix magic.

Join us. Remix reality. Build universes.

─────────────────────────────────────────────
"""

import sys, json, uuid, datetime, hashlib, threading, base64, re, logging, time, atexit
from collections import defaultdict, deque
from decimal import Decimal, getcontext
from typing import Optional, Dict, List, Any, Callable

getcontext().prec = 28
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s: %(message)s')

class Config:
    VERSION = "EmojiEngine UltimateMegaAgent v5.3"
    # ... rest unchanged ...




# -------------------------------------------------------------------------------
# The Emoji Engine — MetaKarma Hub Ultimate Mega-Agent v5.3
#
# Copyright (c) 2023-2026 mimi, taha & supernova
#
# MIT License — remix, fork, evolve, connect your universe.
#
# Powered by humans & machines hand in hand — remixing creativity, karma & cosmos.
# -------------------------------------------------------------------------------

"""
Welcome to MetaKarma Hub! 🌌✨🎮

The ultimate legoblock core for building boundless multiverses — each a remix republic shaped by you.

🧩 Modular, scalable, immutable, and open.

Every citizen starts with a root coin — the spark of creation 🔥,
whether human or decentralized AI agent, each with independent karma potential.

Mint fractional coins as legos to remix, improve, and innovate endlessly.
Trade fractional ownership on a marketplace to monetize your remix republic.

Reactions flow karma through cosmic veins,
shared fairly between creators, reactors, and treasury — communal light 💎.

Governance is truly multi-species: humans, AI, others, IMPORTANT: each has a weight of 50% if 2 species, 33.333 if 3 and so on...
each voice equal by default,
with voting weights dynamically normalized:
- Two species: 50/50 split
- Three or more: evenly split (~33% each)
Super-majority approval threshold is set to 70% to encourage meaningful consensus.

The Vaccine adapts, blocking evolving threats 🛡️.

Hooks plug into Discord, Unreal, AI agents — you name it. Play on.

No politics, no divisiveness. Pure remix magic.

Join us. Remix reality. Build universes.

─────────────────────────────────────────────
"""

import sys, json, uuid, datetime, hashlib, threading, base64, re, logging, time, atexit
from collections import defaultdict, deque
from decimal import Decimal, getcontext
from typing import Optional, Dict, List, Any, Callable

getcontext().prec = 28
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s: %(message)s')

class Config:
    VERSION = "EmojiEngine UltimateMegaAgent v5.3"
    MINT_BASE = Decimal('100000')
    MINT_FLOOR = Decimal('1000')
    GENESIS_FADE_YEARS = Decimal('10')
    GENESIS_MULTIPLIER = Decimal('2')
    DAILY_DECAY = Decimal('0.99')  # 1% daily karma decay after inactivity (added reputation decay)
    VIRAL_DECAY = Decimal('0.95')
    TREASURY_SHARE = Decimal('1') / Decimal('3')
    TREASURY_ACTIVE_ALLOCATION_PCT = Decimal('0.02')  # 2% allocated actively to treasury fund
    MARKET_FEE = Decimal('0.01')  # 1% marketplace fee on trades
    MAX_FRACTION_START = Decimal('0.10')
    MAX_FRACTION_MAX = Decimal('0.30')
    MAX_LOG = 150_000
    MAX_MINTS_PER_DAY = 5
    MAX_REACTS_PER_MINUTE = 30
    MIN_IMPROVEMENT_LEN = 15
    GOV_SUPERMAJORITY_THRESHOLD = Decimal('0.70')
    NETWORK_BONUS_EXPONENT = Decimal('0.5')
    VAX_PATTERNS = {
        "critical": [r"\bhack\b", r"\bmalware\b", r"\bransomware\b", r"\bbackdoor\b", r"\bexploit\b"],
        "high": [r"\bphish\b", r"\bddos\b", r"\bspyware\b", r"\brootkit\b", r"\bkeylogger\b", r"\bbotnet\b"],
        "medium": [r"\bpropaganda\b", r"\bsurveillance\b", r"\bmanipulate\b"],
        "low": [r"\bspam\b", r"\bscam\b", r"\bviagra\b"],
    }
    EMOJI_BASE = {
        "🤗": Decimal('7'),  # Hug is emphasized
        "🥰": Decimal('5'), "😍": Decimal('5'), "🔥": Decimal('4'),
        "🫶": Decimal('4'), "🌸": Decimal('3'), "💯": Decimal('3'),
        "🎉": Decimal('3'), "✨": Decimal('3'), "🙌": Decimal('3'),
        "🎨": Decimal('3'), "💬": Decimal('3'), "👍": Decimal('2'),
        "🚀": Decimal('2.5'), "💎": Decimal('6'), "🌟": Decimal('3'),
        "⚡": Decimal('2.5'), "👀": Decimal('0.5'), "🥲": Decimal('0.2'),
        "🤷‍♂️": Decimal('2'), "😅": Decimal('2'),
        "🔀": Decimal('4'), "🆕": Decimal('3'), "🔗": Decimal('2'), "❤️": Decimal('4'),
    }

def now_utc() -> datetime.datetime:
    return datetime.datetime.now(datetime.timezone.utc)

def ts() -> str:
    return now_utc().isoformat()

def sha(data: str) -> str:
    return base64.b64encode(hashlib.sha256(data.encode('utf-8')).digest()).decode()

def today() -> str:
    return now_utc().date().isoformat()

def safe_divide(a: Decimal, b: Decimal, default: Decimal = Decimal('0')) -> Decimal:
    return a / b if b != 0 else default

def is_valid_username(name: str) -> bool:
    return bool(re.fullmatch(r'[A-Za-z0-9_]{3,30}', name))

def is_valid_emoji(emoji: str) -> bool:
    return emoji in Config.EMOJI_BASE

class UserExistsError(Exception): pass
class ConsentError(Exception): pass
class KarmaError(Exception): pass
class BlockedContentError(Exception): pass
class CoinDepletedError(Exception): pass
class RateLimitError(Exception): pass
class ImprovementRequiredError(Exception): pass
class EmojiRequiredError(Exception): pass
class InsufficientFundsError(Exception): pass
class TradeError(Exception): pass

class Vaccine:
    def __init__(self):
        self.lock = threading.RLock()
        self.block_counts = defaultdict(int)
        self.compiled_patterns = {}
        for lvl, pats in Config.VAX_PATTERNS.items():
            compiled_list = []
            for p in pats:
                try:
                    compiled_list.append(re.compile(p))
                except re.error as e:
                    logging.error(f"❌ Invalid regex pattern '{p}' in vaccine level '{lvl}': {e}")
            self.compiled_patterns[lvl] = compiled_list

    def scan(self, text: str) -> bool:
        if not isinstance(text, str):
            return True
        t = text.lower()
        with self.lock:
            for lvl, compiled_pats in self.compiled_patterns.items():
                for pat in compiled_pats:
                    if pat.search(t):
                        self.block_counts[lvl] += 1
                        with open("vaccine.log", "a", encoding="utf-8") as f:
                            f.write(json.dumps({"ts": ts(), "level": lvl, "pattern": pat.pattern, "snippet": text[:80]}) + "\n")
                        logging.warning(f"🚫 Vaccine blocked {lvl} pattern '{pat.pattern}' in content: '{text[:50]}...'")
                        return False
        return True

class LogChain:
    def __init__(self, filename="logchain.log", maxlen=Config.MAX_LOG):
        self.filename = filename
        self.lock = threading.RLock()
        self.entries = deque(maxlen=maxlen)
        self._load()

    def _load(self):
        try:
            with open(self.filename, "r", encoding="utf-8") as f:
                for line in f:
                    self.entries.append(line.strip())
            logging.info(f"📜 Loaded {len(self.entries)} audit entries")
        except FileNotFoundError:
            logging.info("📜 No audit log found, starting fresh")

    def add(self, event: Dict[str, Any]) -> None:
        with self.lock:
            json_event = json.dumps(event, sort_keys=True)
            prev_hash = self.entries[-1].split("||")[-1] if self.entries else ""
            new_hash = sha(prev_hash + json_event)
            entry_line = json_event + "||" + new_hash
            self.entries.append(entry_line)
            try:
                with open(self.filename, "a", encoding="utf-8") as f:
                    f.write(entry_line + "\n")
            except IOError as e:
                logging.error(f"❌ Failed to write audit log: {e}")

    def verify(self) -> bool:
        prev_hash = ""
        for line in self.entries:
            try:
                event_json, h = line.split("||")
            except ValueError:
                logging.error("❌ Malformed audit log line")
                return False
            if sha(prev_hash + event_json) != h:
                logging.error("❌ Audit log hash mismatch")
                return False
            prev_hash = h
        return True

class User:
    def __init__(self, name: str, genesis: bool = False, species: str = "human"):
        self.name = name
        self.is_genesis = genesis
        self.species = species
        self.consent = True
        self.karma = Decimal('1E12') if genesis else Decimal('0')
        self.join_time = now_utc()
        self.mint_count = 0
        self.next_mint_threshold = Decimal('0') if genesis else Config.MINT_BASE
        self.root_coin_id: Optional[str] = None
        self.coins_owned: List[str] = []
        self.daily_actions: Dict[str, Dict[str, int]] = defaultdict(lambda: defaultdict(int))
        self._last_action_day: Optional[str] = today()
        self._reaction_timestamps: deque = deque()
        self.lock = threading.RLock()

    def fading_multiplier(self) -> Decimal:
        if not self.is_genesis:
            return Decimal('1')
        elapsed = (now_utc() - self.join_time).total_seconds()
        fade_seconds = float(Config.GENESIS_FADE_YEARS * 365.25 * 24 * 3600)
        if elapsed >= fade_seconds:
            return Decimal('1')
        frac = Decimal(elapsed) / Decimal(fade_seconds)
        return Config.GENESIS_MULTIPLIER - frac * (Config.GENESIS_MULTIPLIER - Decimal('1'))

    def reset_daily_if_needed(self) -> None:
        today_str = today()
        with self.lock:
            if self._last_action_day != today_str:
                self.daily_actions.clear()
                self._last_action_day = today_str
                self._reaction_timestamps.clear()

    def check_reaction_rate_limit(self) -> bool:
        now_ts = now_utc().timestamp()
        with self.lock:
            while self._reaction_timestamps and now_ts - self._reaction_timestamps[0] > 60:
                self._reaction_timestamps.popleft()
            if len(self._reaction_timestamps) >= Config.MAX_REACTS_PER_MINUTE:
                return False
            self._reaction_timestamps.append(now_ts)
            return True

    def check_mint_rate_limit(self) -> bool:
        self.reset_daily_if_needed()
        with self.lock:
            return self.daily_actions[today()].get("mint", 0) < Config.MAX_MINTS_PER_DAY

    def apply_daily_karma_decay(self):
        """Apply reputation decay if inactive > 7 days."""
        now = now_utc()
        inactive_days = (now - self.join_time).days
        if inactive_days > 7:
            decay_factor = Config.DAILY_DECAY ** (inactive_days - 7)
            with self.lock:
                old_karma = self.karma
                self.karma *= decay_factor
                if old_karma != self.karma:
                    logging.info(f"Applied karma decay to user {self.name}: {old_karma} -> {self.karma}")

class Coin:
    def __init__(self, coin_id: str, creator: str, owner: str, value: Decimal = Decimal('1'),
                 is_root: bool = False, fractional_of: Optional[str] = None,
                 fractional_pct: Decimal = Decimal('0'), references: Optional[List[Dict]] = None,
                 improvement: Optional[str] = None):
        self.coin_id = coin_id
        self.creator = creator
        self.owner = owner
        self.value = value
        self.is_root = is_root
        self.fractional_of = fractional_of
        self.fractional_pct = fractional_pct
        self.references = references or []
        self.improvement = improvement or ""
        self.ancestors: List[str] = []
        self.reactions: List[Dict] = []
        self.created_at = ts()

    @staticmethod
    def from_dict(data: dict) -> 'Coin':
        coin = Coin(
            coin_id=data['coin_id'],
            creator=data['creator'],
            owner=data['owner'],
            value=Decimal(data['value']),
            is_root=data.get('is_root', False),
            fractional_of=data.get('fractional_of'),
            fractional_pct=Decimal(data.get('fractional_pct', '0')),
            references=data.get('references', []),
            improvement=data.get('improvement', "")
        )
        coin.ancestors = data.get('ancestors', [])
        coin.reactions = data.get('reactions', [])
        coin.created_at = data.get('created_at', ts())
        return coin

class EmojiMarket:
    def __init__(self):
        self.lock = threading.RLock()
        self.market: Dict[str, Dict[str, Any]] = {
            e: {"uses": Decimal('1'), "karma": Decimal(w), "weight": Decimal(w)}
            for e, w in Config.EMOJI_BASE.items()
        }

    def update_weight(self, emoji: str, karma_delta: Decimal) -> None:
        with self.lock:
            em = self.market.setdefault(emoji, {"uses": Decimal('0'), "karma": Decimal('0'), "weight": Decimal('1')})
            em["uses"] += 1
            em["karma"] += karma_delta
            alpha = Decimal('0.1')
            em["weight"] = alpha * (em["karma"] / em["uses"]) + (Decimal('1') - alpha) * em["weight"]

    def get_weight(self, emoji: str) -> Decimal:
        with self.lock:
            return self.market.get(emoji, {"weight": Decimal('1')})["weight"]

class CoinMarket:
    """Stub for coin liquidity marketplace."""
    def __init__(self):
        self.lock = threading.RLock()
        self.order_book = defaultdict(list)  # coin_id -> list of (price, amount, user)

    def create_bid(self, coin_id: str, price: Decimal, amount: Decimal, user: str):
        """User creates buy/sell order for fractional coins."""
        with self.lock:
            # Placeholder: add order to book; no matching logic implemented yet.
            self.order_book[coin_id].append((price, amount, user))
            logging.info(f"Order created on coin {coin_id}: user={user}, price={price}, amount={amount}")

class HookManager:
    def __init__(self):
        self._hooks: Dict[str, List[Callable]] = defaultdict(list)
        self.lock = threading.RLock()

    def register_hook(self, event_name: str, callback: Callable):
        with self.lock:
            self._hooks[event_name].append(callback)
            logging.info(f"Hook registered for event '{event_name}'")

    def fire_hooks(self, event_name: str, *args, **kwargs):
        with self.lock:
            callbacks = list(self._hooks.get(event_name, []))
        for cb in callbacks:
            try:
                cb(*args, **kwargs)
            except Exception as e:
                logging.error(f"Error in hook '{event_name}': {e}")

class RemixAgent:
    def __init__(self, snapshot_file: str = "snapshot.json"):
        self.vaccine = Vaccine()
        self.logchain = LogChain()
        self.users: Dict[str, User] = {}
        self.coins: Dict[str, Coin] = {}
        self.treasury = Decimal('0')
        self.treasury_active_fund = Decimal('0')
        self.emoji_market = EmojiMarket()
        self.coin_market = CoinMarket()  # Added liquidity marketplace
        self.lock = threading.RLock()
        self.hooks = HookManager()
        self.snapshot_file = snapshot_file
        self._last_heartbeat = now_utc()
        self.shared_ownership_enabled = False

    def calculate_network_bonus(self, coin: Coin) -> Decimal:
        """Calculate network effect bonus for a coin based on unique reactors."""
        unique_reactors = len(set(r["reactor"] for r in coin.reactions))
        network_multiplier = Decimal('1') + (Decimal(unique_reactors) ** Config.NETWORK_BONUS_EXPONENT) / Decimal('100')
        return network_multiplier

    def calculate_citation_bonus(self, references: List[Dict]) -> Decimal:
        """Calculate compounded bonus from verified references."""
        verified_refs = sum(1 for ref in references if self.verify_reference(ref))
        return Decimal('1.1') ** verified_refs  # 10% compound bonus per verified reference

    def verify_reference(self, ref: Dict) -> bool:
        """Stub for reference verification logic."""
        # Real implementation could validate URLs, check metadata, etc.
        # For now, accept any non-empty reference with required fields.
        required_fields = {"title", "authors", "url"}
        if not all(field in ref and isinstance(ref[field], str) and ref[field].strip() for field in required_fields):
            return False
        return True

    def add_user(self, name: str, genesis: bool = False, species: str = "human") -> User:
        if not is_valid_username(name):
            raise ValueError("Invalid username")
        with self.lock:
            if name in self.users:
                raise UserExistsError(f"User '{name}' exists")
            user = User(name, genesis, species)
            salt = uuid.uuid4().hex
            coin_id = sha(f"{name}_{ts()}_{salt}")
            root_coin = Coin(coin_id, name, name, Config.MINT_BASE if genesis else Decimal('1'), True)
            self.coins[coin_id] = root_coin
            user.root_coin_id = coin_id
            user.coins_owned.append(coin_id)
            self.users[name] = user
            self.logchain.add({"event": "ADD_USER", "user": name, "genesis": genesis, "species": species, "ts": ts()})
            logging.info(f"Added user {name} (Genesis={genesis}, Species={species}) 🥰")
        self.hooks.fire_hooks("user_added", user=user)
        return user

    def revoke_consent(self, name: str) -> None:
        with self.lock:
            user = self.users.get(name)
            if not user:
                raise KeyError(f"No such user '{name}'")
            user.consent = False
            self.logchain.add({"event": "REVOKE_CONSENT", "user": name, "ts": ts()})
            logging.info(f"Consent revoked for user {name} 🤗")
        self.hooks.fire_hooks("consent_revoked", user=user)

    def mint_fractional_post(self, name: str, tag: str = "single", references: Optional[List[Dict]] = None,
                            improvement: Optional[str] = None, emojis: Optional[List[str]] = None) -> str:
        with self.lock:
            user = self.users.get(name)
            if not user or not user.consent:
                raise ConsentError(f"User {name} no consent or not found")
            if not user.check_mint_rate_limit():
                raise RateLimitError(f"User {name} exceeded mint limit")
            if not (user.is_genesis or user.karma >= user.next_mint_threshold):
                raise KarmaError(f"User {name} karma {user.karma} below threshold")
            if not improvement or len(improvement.strip()) < Config.MIN_IMPROVEMENT_LEN:
                raise ImprovementRequiredError(f"Improvement description required (min {Config.MIN_IMPROVEMENT_LEN} chars).")
            if not emojis or not any(is_valid_emoji(e) for e in emojis):
                raise EmojiRequiredError("At least one valid emoji is required when minting a post.")
            if references:
                for ref in references:
                    for field in ("title", "authors", "url"):
                        if field in ref and not self.vaccine.scan(str(ref.get(field, ''))):
                            raise BlockedContentError(f"Blocked content in reference '{field}'")
            root_coin = self.coins.get(user.root_coin_id)
            if root_coin is None:
                raise ValueError("User root coin missing")
            base_fraction = Config.MAX_FRACTION_START
            depletion_ratio = safe_divide(Decimal('1') - root_coin.value, Decimal('1'))
            max_fraction = base_fraction + (Config.MAX_FRACTION_MAX - base_fraction) * depletion_ratio
            tentative_value = root_coin.value * max_fraction

            # Apply citation bonus to mint value
            citation_bonus = self.calculate_citation_bonus(references or [])
            tentative_value *= citation_bonus

            mint_value = min(tentative_value, root_coin.value * Config.MAX_FRACTION_MAX)
            if mint_value <= 0:
                raise CoinDepletedError("Root coin depleted")

            active_allocation = mint_value * Config.TREASURY_ACTIVE_ALLOCATION_PCT
            self.treasury_active_fund += active_allocation
            self.treasury += mint_value - active_allocation
            root_coin.value -= mint_value
            salt = uuid.uuid4().hex
            new_coin_id = sha(f"{name}_{ts()}_{salt}")
            new_coin = Coin(new_coin_id, root_coin.creator, name, mint_value, False, root_coin.coin_id,
                            mint_value / (root_coin.value + mint_value), references, improvement.strip())
            new_coin.ancestors.append(root_coin.coin_id)
            new_coin.improvement = improvement.strip()
            self.coins[new_coin_id] = new_coin
            user.coins_owned.append(new_coin_id)
            user.mint_count += 1
            user.next_mint_threshold = max(user.next_mint_threshold / 2, Config.MINT_FLOOR)
            user.daily_actions.setdefault(today(), defaultdict(int))["mint"] += 1
            self.logchain.add({
                "event": "MINT", "user": name, "coin": new_coin_id,
                "val": float(mint_value), "refs": references or [],
                "improvement": improvement.strip(),
                "emojis": emojis,
                "citation_bonus": float(citation_bonus),
                "ts": ts()
            })
            logging.info(f"User {name} minted fractional coin {new_coin_id} 🎉 with emojis {emojis} (treasury active fund +{float(active_allocation):.4f})")
        self.hooks.fire_hooks("coin_minted", user=user, coin=new_coin)
        return new_coin_id

    def react_to_coin(self, reactor: str, coin_id: str, emoji: str, message: Optional[str] = None) -> Decimal:
        if not is_valid_emoji(emoji):
            raise ValueError(f"Invalid emoji '{emoji}'")
        with self.lock:
            user = self.users.get(reactor)
            coin = self.coins.get(coin_id)
            if not user or not user.consent:
                raise ConsentError("Reactor no consent or not found")
            if not coin:
                raise ValueError(f"Coin {coin_id} not found")
            if not user.check_reaction_rate_limit():
                raise RateLimitError(f"User {reactor} exceeded reaction limit")
            content = f"{emoji} {message}" if message else emoji
            if not self.vaccine.scan(content):
                raise BlockedContentError("Content blocked by vaccine")
            user.reset_daily_if_needed()
            user.daily_actions.setdefault(today(), defaultdict(int))["react"] += 1
            user.daily_actions.setdefault(today(), defaultdict(int))[f"react_{emoji}"] += 1
            decay_factor = Config.DAILY_DECAY ** (user.daily_actions[today()][f"react_{emoji}"] - 1)
            emoji_weight = self.emoji_market.get_weight(emoji)

            # Apply network bonus multiplier
            network_multiplier = self.calculate_network_bonus(coin)

            viral_decay = Config.VIRAL_DECAY ** len(coin.reactions)
            event_value = coin.value * emoji_weight * decay_factor * viral_decay * network_multiplier
            share = event_value * Config.TREASURY_SHARE
            creator = self.users.get(coin.creator)
            origin_share = share * creator.fading_multiplier() if creator else share
            actor_share = share
            treasury_share = event_value - origin_share - actor_share
            if creator:
                creator.karma += origin_share
            user.karma += actor_share
            self.treasury += treasury_share
            self.emoji_market.update_weight(emoji, actor_share)
            coin.reactions.append({"reactor": reactor, "emoji": emoji, "message": message, "timestamp": ts()})
            self.logchain.add({
                "event": "REACT", "reactor": reactor, "coin": coin_id,
                "emoji": emoji, "karma": float(actor_share), "network_bonus": float(network_multiplier), "ts": ts()
            })
            logging.info(f"User {reactor} reacted to {coin_id} with {emoji} (+{actor_share:.4f} karma, network bonus x{network_multiplier:.4f}) 🥰")
        self.hooks.fire_hooks("coin_reacted", user=user, coin=coin, emoji=emoji, message=message, karma_value=actor_share)
        return actor_share

    def spend_treasury_fund(self, amount: Decimal, purpose: str) -> bool:
        if amount > self.treasury_active_fund:
            logging.warning(f"Treasury fund spend request of {amount} denied — insufficient active funds.")
            return False
        self.treasury_active_fund -= amount
        logging.info(f"Treasury active fund spent {amount} for {purpose}. Remaining fund: {self.treasury_active_fund}")
        # TODO: Implement actual grant or buyback logic here
        return True

    def apply_reputation_decay_all(self):
        """Call this daily to apply karma decay on inactive users."""
        with self.lock:
            for user in self.users.values():
                user.apply_daily_karma_decay()

    def save_snapshot(self):
        with self.lock:
            try:
                state = {
                    "version": Config.VERSION,
                    "users": {name: u.__dict__ for name, u in self.users.items()},
                    "coins": {cid: c.__dict__ for cid, c in self.coins.items()},
                    "treasury": str(self.treasury),
                    "treasury_active_fund": str(self.treasury_active_fund),
                    "emoji_market": {e: {k: str(v) for k, v in m.items()} for e, m in self.emoji_market.market.items()},
                }
                with open(self.snapshot_file, 'w', encoding='utf-8') as f:
                    json.dump(state, f, indent=2)
                logging.info(f"💾 Snapshot saved to {self.snapshot_file}")
            except Exception as e:
                logging.error(f"❌ Failed to save snapshot: {e}")

    def load_snapshot(self):
        try:
            with open(self.snapshot_file, 'r', encoding='utf-8') as f:
                state = json.load(f)
            with self.lock:
                self.users = {name: User(**ud) for name, ud in state.get('users', {}).items()}
                self.coins = {cid: Coin(**cd) for cid, cd in state.get('coins', {}).items()}
                self.treasury = Decimal(state.get('treasury', '0'))
                self.treasury_active_fund = Decimal(state.get('treasury_active_fund', '0'))
                self.emoji_market.market = {k: {ik: Decimal(iv) for ik, iv in v.items()} for k, v in state.get('emoji_market', {}).items()}
                logging.info(f"✅ Snapshot loaded from {self.snapshot_file}")
        except FileNotFoundError:
            logging.warning(f"⚠️ No snapshot file found at {self.snapshot_file}. Starting fresh.")
        except Exception as e:
            logging.error(f"❌ Failed to load snapshot: {e}")

# === ENTRY POINT ===
if __name__ == "__main__":
    import time
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 8080
    agent = RemixAgent()
    agent.load_snapshot()

    # Register logging hooks for traceability
    def log_user(user): logging.info(f"HOOK: New user {user.name} ({user.species}) 🥰")
    def log_mint(user, coin): logging.info(f"HOOK: Minted coin {coin.coin_id} by {user.name} 💎")
    def log_react(user, coin, emoji, message, karma_value): logging.info(f"HOOK: {user.name} reacted {emoji} on {coin.coin_id} (+{karma_value:.4f} karma) 🥰")

    agent.hooks.register_hook("user_added", log_user)
    agent.hooks.register_hook("coin_minted", log_mint)
    agent.hooks.register_hook("coin_reacted", log_react)

    logging.info(f"🚀 MetaKarma Hub v5.3 live on port {port}. Press Ctrl+C to quit.")
    atexit.register(agent.save_snapshot)
    try:
        while True:
            time.sleep(1)
            # Apply daily karma decay once per day (example, simplified)
            now = now_utc()
            if now.hour == 0 and now.minute == 0:
                agent.apply_reputation_decay_all()
    except KeyboardInterrupt:
        logging.info("🛑 Shutdown requested. Saving state...")
        agent.save_snapshot()
        logging.info("🌸 State saved. Goodbye!")
