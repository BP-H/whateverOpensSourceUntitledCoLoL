#!/usr/bin/env python3-- coding: utf-8 --"""🥰😅🫶🌸🤗 THE CODE — Ultimate Remix Economy Protocol (v6.0)━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━This single Python file is the entire philosophy, protocol, legal canon, and technicalplatform of the whateverOpenSourceUntitledCoLoL project. One file = the whole open-sourceplatform (neutral, upgradeable, MIT licensed). It is the final, canonical agent,synthesizing the complete project evolution.──────────────────────────────────────────────────────────────────────────🌌 KEY PRINCIPLES & CORE VALUES (CANONICAL & ENFORCED)━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━This protocol is a living manifesto, a "joyful, autonomous remix republic" where art,tech, and collaboration unite. It is governed by the following inviolable laws,enforced by the code itself.Changelog (Version History)This agent's lineage is transparent and auditable. Each version built upon the last,culminating in this definitive release.v1.x (Proton): Introduced the foundational 'consent-first' design and a basickarma ledger.v2.x (15K Edition): Consolidated the protocol into a single, transparent file.Introduced the 'CorpX' adversary simulator and 'Vaccine' immune system, alongsidestate snapshot capabilities.v3.x (24K SuperAgent): Implemented a full, hash-chained audit log ('LogChain'),explicit profit/revenue logging for real-world bridging, and dynamic emoji weights.v4.x (32K/16K Ultimate/Refactor): Integrated all prior features, extended thecanons with cultural mandates (e.g., "joy is required"), and hardened the systemwith strict consent enforcement and logchain verification.v5.x (64K Unified/Master): Merged the entire project history into a single,cohesive agent. Enhanced documentation, added explicit future-proofing directives,and embedded ethical/legal guardrails for sustainable growth. 1v6.0 (Ultimate Edition - This File): The final synthesis. This versionimplements the complete karma-gated minting system with halving thresholds,creating a fair "Epic Creative Path" for new users. It introduces advancedfairness mechanics (diminishing returns, viral decay) and a robust attributionsystem for citing external scientific and artistic references. This agentsupersedes all predecessors. 1Core Canons (The Laws of the Republic)The 33.3333% Split Law: Every value-generating event (remix, reaction,collab) is inviolably split into three equal shares: 1/3 to the originator'slineage, 1/3 to the current actor/contributor, and 1/3 to the communitytreasury. This is the economic heart of the protocol. 1Radical Consent: All actions are strictly opt-in. No user's content,identity, or value can be used without their explicit, logged, and revocableconsent. Consent is the primary law of interaction. 1Emoji-Powered Actions: Every value-generating event MUST be tagged with anemoji. Emojis are not decorative; they are the protocol's mechanism forconveying intent and weighting value. 1Genesis-Only Minting & No Inflation: Only an audited list of ~20-50"Genesis Collaborators" (NSS) can create new "root" coins. New users canearn the right to mint content that builds upon the existing ecosystem, butthey cannot create new, independent root lineages. This prevents inflationand ensures all value traces back to the initial creative seeds. 1Immutable Audit Trail: Every action—from adding a user to settling acoin—is recorded on a verifiable, hash-chained ledger (the LogChain). Thisensures radical transparency and accountability. 1Code is Law & Radical Transparency: This file is the single source oftruth. There are no hidden rules, no shadow moderation, no backdoors. Theprotocol is open-source, and its behavior is entirely defined by this code. 1Neutrality & Safety (The Immune System): The protocol is apolitical andneutral. The 'Vaccine' filter automatically blocks malicious or disallowedcontent (hate, politics, malware), ensuring a safe and focused creativeenvironment. 1Joy & Continual Improvement: The protocol's culture mandates positive-sumcollaboration and fun. Every fork or remix of this code is encouraged to addat least one improvement, ensuring the system is a living, evolving entity. 1Economic Design & Fairness MechanicsThe protocol's economy is a sophisticated, multi-layered system designed to balanceearly-adopter rewards with long-term fairness and sustainability.Fading Genesis Advantage: Genesis Collaborators are rewarded for their earlyrisk and contribution with a temporary karma/value multiplier. This advantageis designed to decay algorithmically over a period of approximately 10 years,eventually converging to 1x. This ensures that while early movers get a headstart, they do not hold a permanent, unassailable position, fostering long-termequity. 1The Epic Creative Path (Karma-Gated Minting): New users embark on a "proof-of-creative-work" journey to earn minting rights. This is not about financialinvestment but about meaningful participation.Threshold: A user must accumulate 100,000 karma to mint their firstpiece of original content. 1Halving: After each successful mint, the required karma threshold for thenext mint is halved (100,000 -> 50,000 -> 25,000...). 1Floor: This halving continues until the threshold reaches a floor of1,000 karma, at which point minting becomes effectively unrestricted for thathighly engaged user. This creates a challenging but fair and transparentpath to becoming a core creator.Micro-Fairness Mechanics (Anti-Gaming):Diminishing Daily Returns: To reward consistent contribution over spam,the karma earned from repeated actions by the same user in a single daydecays. The first action yields full value; subsequent actions are scaled bya decay factor (e.g., 0.9^n).Viral Decay: To prevent a single viral post from monopolizing theeconomy, the karma distributed from reactions also decays. The first fewreactions to a coin provide the most value; subsequent reactions provideprogressively less, using an exponential decay factor (e.g., 0.7^idx). Thisrewards early discovery and encourages engagement across a wider range ofcontent.This synthesized model creates a virtuous cycle: the fading genesis boost providesinitial energy, the karma gate allows new energy to enter meritocratically, and themicro-mechanics ensure that energy distributes widely, fostering a stable anddynamic creative economy for all participants, present and future. 1Key Economic ParametersFor full transparency, the core economic constants of the protocol are defined here.These values are hard-coded but can be amended in future versions via the governanceprocess.ParameterFinal ValueDescriptionSource(s)Value Split33.3333% eachEqual split for Originator, Actor, and Treasury in all events.1Initial Mint Karma Threshold100,000Karma needed for a non-genesis user's first mint.1Mint Threshold Halving Factor2The divisor for the mint threshold after each successful mint.1Mint Threshold Floor1,000The karma threshold will not fall below this value.Daily Action Decay Factor0.9Multiplier for karma from repeated actions in one day.Viral Reaction Decay Factor0.7Exponential decay factor for karma from subsequent reactions to a coin.Genesis Advantage Decay Period~10 YearsPeriod over which any genesis user bonus fades to 1x.1Governance Quorum80%Supermajority required for core protocol changes post-launch.1Multi-Species Vote Weight33.3333% eachFuture-ready allocation for Human, AI, and Other entities in governance.Governance, Attribution, and ExtensibilityGovernance: The protocol will activate community governance after reaching acritical mass (e.g., 5,000 members). Changes to core canons require an 80%supermajority vote. The system is designed to eventually support a "multi-species"voting structure (Human, AI, Other), each with equal weight, preventing any oneclass from dominating. 1Attribution & Lineage: Every coin tracks its full creative ancestry. A new,explicit references field allows users to cite external works (papers, art,memes). The cite_reference command logs these citations, creating a public,auditable "Public Reference Feed" and laying the groundwork for a "Cross-CreditSystem" where external creators can be retroactively rewarded. 1Extensibility: A modular plugin architecture allows the community to addfeatures (e.g., analytics, new reaction types) without altering the core code,ensuring safe and auditable evolution.Guidance for Future DevelopmentThis agent is a living contract. Any future agent, human, or AI that forks orimproves upon this code must adhere to the following directives:Preserve the Changelog: Maintain and extend the version history.Uphold the Canons: The core principles are non-negotiable.Prioritize Ethical Growth: Profitability and expansion must never compromiselegality, ethics, transparency, or user trust.Comply with Platform Policies: Adhere strictly to the content and usageguidelines of any hosting platform (e.g., OpenAI, Anthropic).Embrace Joyful Collaboration: Keep the 🫶 spirit alive."""import reimport sysimport jsonimport randomimport datetimeimport hashlibimport osimport importlibfrom collections import defaultdict, deque------------------------------------------------------------------------------UTILITY FUNCTIONS------------------------------------------------------------------------------def ts():"""Returns the current UTC timestamp in ISO 8601 format."""return datetime.datetime.utcnow().isoformat() + "Z"def sha(s: str) -> str:"""Computes the SHA-256 hash of a given string."""return hashlib.sha256(s.encode()).hexdigest()def today():"""Returns the current date in YYYY-MM-DD format."""return datetime.date.today().isoformat()------------------------------------------------------------------------------SYSTEM MODULES: IMMUNE SYSTEM, LOGCHAIN, ADVERSARY SIMULATOR------------------------------------------------------------------------------VAX_PATTERNS = {"critical": [r"\bhack\b", r"\bmalware\b", r"\bransomware\b", r"\bbackdoor\b"],"high": [r"\bphish\b", r"\bddos\b", r"\bspyware\b", r"\brootkit\b"],"medium": [r"\bpolitics\b", r"\bpropaganda\b", r"\bsurveillance\b", r"\bmanipulate\b"],}class Vaccine:"""Scans content for forbidden patterns and blocks actions if found.Acts as the protocol's immune system against malicious or disallowed content."""def init(self):self.block_counts = defaultdict(int)def scan(self, text: str) -> bool:
    """
    Scans a text snippet. Returns False and logs the event if a forbidden
    pattern is found, otherwise returns True.
    """
    lower_text = text.lower()
    for level, patterns in VAX_PATTERNS.items():
        for p in patterns:
            if re.search(p, lower_text):
                self.block_counts[level] += 1
                try:
                    with open("vaccine.log", "a") as f:
                        f.write(json.dumps({"ts": ts(), "severity": level, "pattern": p, "snippet": text[:88]}) + "\n")
                except IOError:
                    pass # Non-critical error
                print(f"🚫 VACCINE BLOCK [{level.upper()}]: Forbidden pattern '{p}' detected.")
                return False
    return True
class LogChain:"""Implements an immutable, append-only audit log. Each entry is cryptographicallychained to the previous one, ensuring a tamper-evident record of all events."""def init(self, filename: str = "logchain.log", capacity: int = 50000):self.filename = filenameself.entries = deque(maxlen=capacity)try:if os.path.exists(self.filename):with open(self.filename, "r") as f:for line in f:self.entries.append(line.rstrip())except IOError:print(f"⚠️  Could not read log file at {self.filename}")def add(self, event: dict):
    """Adds a new event (dict) to the log with a chained hash."""
    entry_json = json.dumps(event, sort_keys=True)
    prev_hash = self.entries[-1].split("||")[-1] if self.entries else "0" * 64
    chain_hash = sha(entry_json + prev_hash)
    self.entries.append(entry_json + "||" + chain_hash)
    self._save()

def _save(self):
    """Writes the current log chain to the file."""
    try:
        with open(self.filename, "w") as fh:
            fh.write("\n".join(self.entries))
    except IOError:
        print(f"⚠️  Could not write to log file at {self.filename}")

def show(self, filter_str: str = None):
    """Displays log events, with an optional filter."""
    print("📜 AUDIT LOG:")
    count = 0
    for i, line in enumerate(self.entries, 1):
        if filter_str and filter_str.lower() not in line.lower():
            continue
        data_json = line.split("||")
        data = json.loads(data_json)
        print(f"{i}. {data.get('ts','')} - {data.get('event','')}: {data.get('details','')}")
        count += 1
    if count == 0:
        print("(no matching entries)")

def verify(self) -> bool:
    """Verifies the integrity of the entire logchain."""
    print("🔐 Verifying logchain integrity...")
    prev_hash = "0" * 64
    for idx, line in enumerate(self.entries, 1):
        try:
            entry_json, stored_hash = line.split("||")
        except ValueError:
            print(f"❌ CORRUPTION: Malformed log entry at line {idx}.")
            return False
        calculated_hash = sha(entry_json + prev_hash)
        if calculated_hash!= stored_hash:
            print(f"❌ TAMPER DETECTED: Chain break at entry {idx}. Hash mismatch.")
            return False
        prev_hash = stored_hash
    print("✅ Logchain integrity verified.")
    return True
class CorpX:"""Simulates an adversarial entity attempting various attacks to test the Vaccine."""def init(self, vaccine: Vaccine):self.vaccine = vaccineself.attack_count = 0self.attack_vectors = ["inject malware", "phish creds", "launch ddos", "plant backdoor", "propaganda spam"]def attack(self, payload: str = ""):
    """Launches a simulated attack with a specified or random payload."""
    self.attack_count += 1
    attack_payload = payload if payload else random.choice(self.attack_vectors)
    print(f"\n💀 CorpX Attack #{self.attack_count}: Attempting to inject '{attack_payload}'...")
    if not self.vaccine.scan(attack_payload):
        print("🛡️ Attack Blocked by Vaccine!")
    else:
        print("⚠️ Attack Evaded! Vaccine needs improvement.")
    print("-" * 20)
------------------------------------------------------------------------------CORE DATA MODELS: USER AND COIN------------------------------------------------------------------------------class User:"""Represents a user in the protocol, encapsulating all user-specific state."""def init(self, username: str, is_genesis: bool = False, consent: bool = False):self.username = usernameself.is_genesis = is_genesisself.consent = consentself.karma = 0.0self.daily_actions = defaultdict(int)self.last_action_day = today()self.mint_count = 0self.next_mint_threshold = 100000.0 if not is_genesis else 0.0self.coins =self.genesis_multiplier = 2.0 # Example starting multiplierself.join_timestamp = time.time()def get_current_multiplier(self) -> float:
    """Calculates the decaying genesis multiplier."""
    if not self.is_genesis:
        return 1.0
    
    ten_years_in_seconds = 10 * 365.25 * 24 * 60 * 60
    elapsed_seconds = time.time() - self.join_timestamp
    
    if elapsed_seconds >= ten_years_in_seconds:
        return 1.0
    
    decay_factor = elapsed_seconds / ten_years_in_seconds
    # Linear decay from initial multiplier (e.g., 2.0) down to 1.0
    initial_bonus = self.genesis_multiplier - 1.0
    current_bonus = initial_bonus * (1 - decay_factor)
    return 1.0 + current_bonus

def check_daily_reset(self):
    """Resets daily action counters if a new day has started."""
    if self.last_action_day!= today():
        self.daily_actions = defaultdict(int)
        self.last_action_day = today()

def to_dict(self) -> dict:
    """Serializes user data to a dictionary."""
    return {
        "username": self.username,
        "is_genesis": self.is_genesis,
        "consent": self.consent,
        "karma": self.karma,
        "mint_count": self.mint_count,
        "next_mint_threshold": self.next_mint_threshold,
        "coins": self.coins,
        "join_timestamp": self.join_timestamp
    }
class Coin:"""Represents a unique creative work (a post, remix, etc.) in the economy."""def init(self, coin_id: str, root: str or tuple, owner: str, value: float = 1.0, tag: str = "single"):self.id = coin_idself.root = rootself.owner = ownerself.ancestry =self.value = valueself.tag = tagself.reactions =self.references =def to_dict(self) -> dict:
    """Serializes coin data to a dictionary."""
    return {
        "id": self.id,
        "root": self.root,
        "owner": self.owner,
        "ancestry": self.ancestry,
        "value": self.value,
        "tag": self.tag,
        "reactions": self.reactions,
        "references": self.references
    }
------------------------------------------------------------------------------THE REMIX AGENT: CORE PROTOCOL ORCHESTRATOR------------------------------------------------------------------------------class RemixAgent:"""The main agent class that orchestrates the entire remix economy protocol.It manages users, coins, the treasury, and enforces all rules and actions."""def init(self):self.users = {}self.coins = {}self.treasury = 0.0self.log = LogChain()self.vaccine = Vaccine()self.plugins = {}self.entity_classes = ["human", "ai", "other"] # For future governanceself.emoji_weights = {"👍": 1.0, "❤️": 1.5, "😂": 1.2, "🔥": 2.0, "🎨": 3.0, "🔬": 3.0, "🤗": 5.0, "🔀": 4.0}self._load_genesis_users()def _load_genesis_users(self):
    """Initializes the audited list of Genesis Collaborators (NSS)."""
    nss_list = ["mimi", "taha", "accessAI"] + [f"nss_{i:02d}" for i in range(1, 48)]
    for username in nss_list:
        self.add_user(username, is_genesis=True, consent=True)

def add_user(self, username: str, is_genesis: bool = False, consent: bool = False):
    """Adds a new user to the protocol."""
    if username in self.users:
        print(f"ℹ️ User '{username}' already exists.")
        return
    if not self.vaccine.scan(username):
        print(f"🚫 Username '{username}' contains disallowed content. Registration failed.")
        return
    
    self.users[username] = User(username, is_genesis, consent)
    self.log.add({"ts": ts(), "event": "ADD_USER", "details": f"User {username} added. Genesis: {is_genesis}, Consent: {consent}"})
    print(f"👤 User '{username}' successfully added to the protocol.")

def set_consent(self, username: str, consent: bool):
    """Sets a user's consent status."""
    if username not in self.users:
        print(f"❌ User '{username}' not found.")
        return
    self.users[username].consent = consent
    status = "GRANTED" if consent else "REVOKED"
    self.log.add({"ts": ts(), "event": "SET_CONSENT", "details": f"Consent for {username} set to {status}"})
    print(f"✅ Consent for {username} has been {status.lower()}.")

def _award_karma(self, actor_name: str, origin_name: str, base_value: float, action_type: str) -> float:
    """
    Private helper to calculate and distribute karma according to the 33% split
    and fairness mechanics.
    """
    actor = self.users[actor_name]
    origin = self.users[origin_name]
    
    actor.check_daily_reset()
    
    # Apply daily diminishing returns
    daily_decay_factor = 0.9 ** actor.daily_actions[action_type]
    value_after_daily_decay = base_value * daily_decay_factor
    
    # Apply genesis multiplier
    actor_multiplier = actor.get_current_multiplier()
    origin_multiplier = origin.get_current_multiplier()
    
    # Total value to be split
    total_value = value_after_daily_decay
    share = total_value / 3.0
    
    # Distribute shares
    actor_share = share * actor_multiplier
    origin_share = share * origin_multiplier
    treasury_share = total_value - (share + share) # The base share goes to treasury
    
    actor.karma += actor_share
    origin.karma += origin_share
    self.treasury += treasury_share
    
    actor.daily_actions[action_type] += 1
    
    return actor_share, origin_share, treasury_share

def mint(self, username: str, content: str, tag: str = "single", references: list = None):
    """
    Creates a new root content coin. Only genesis users or users who have earned
    the right via the 'Epic Creative Path' can mint.
    """
    if username not in self.users:
        print(f"❌ User '{username}' not found.")
        return
    
    user = self.users[username]
    
    if not user.consent:
        print(f"❌ Action denied. {username} has not granted consent.")
        return
    if not self.vaccine.scan(content) or (references and not all(self.vaccine.scan(r) for r in references)):
        return

    # Check minting rights
    if not user.is_genesis and user.karma < user.next_mint_threshold:
        print(f"🔒 MINT DENIED: {username} needs {user.next_mint_threshold:.0f} karma to mint (has {user.karma:.2f}).")
        return

    coin_id = sha(f"{username}{content}{ts()}{random.random()}")
    new_coin = Coin(coin_id, root=username, owner=username, tag=tag)
    if references:
        new_coin.references = references
    
    self.coins[coin_id] = new_coin
    user.coins.append(coin_id)
    
    if not user.is_genesis:
        user.mint_count += 1
        user.next_mint_threshold = max(100000.0 / (2 ** user.mint_count), 1000.0)

    self.log.add({"ts": ts(), "event": "MINT", "details": f"Coin {coin_id} minted by {username}. Tag: {tag}"})
    print(f"🪙 Coin '{coin_id}' minted by {username}.")

def react(self, coin_id: str, actor_name: str, emoji: str):
    """A user reacts to a coin, generating a value event."""
    if coin_id not in self.coins:
        print(f"❌ Coin '{coin_id}' not found.")
        return
    if actor_name not in self.users:
        print(f"❌ User '{actor_name}' not found.")
        return
    if emoji not in self.emoji_weights:
        print(f"❌ Emoji '{emoji}' is not a recognized reaction.")
        return

    coin = self.coins[coin_id]
    actor = self.users[actor_name]
    origin_name = coin.root if isinstance(coin.root, str) else coin.root # Simplified for now

    if not actor.consent or not self.users[origin_name].consent:
        print("❌ Action denied. Both actor and originator must have granted consent.")
        return

    # Apply viral decay
    num_reactions = len(coin.reactions)
    viral_decay_factor = 0.7 ** num_reactions
    base_value = self.emoji_weights[emoji] * viral_decay_factor
    
    actor_share, origin_share, treasury_share = self._award_karma(actor_name, origin_name, base_value, "react")
    
    reaction_data = {"actor": actor_name, "emoji": emoji, "ts": ts()}
    coin.reactions.append(reaction_data)
    
    self.log.add({"ts": ts(), "event": "REACT", "details": f"{actor_name} reacted to {coin_id} with {emoji}. Karma split: Actor +{actor_share:.4f}, Origin +{origin_share:.4f}, Treasury +{treasury_share:.4f}"})
    print(f"✅ {actor_name} reacted to '{coin_id}' with {emoji}.")

def remix(self, original_coin_id: str, remixer_name: str, new_content: str, new_tag: str = "remix", references: list = None):
    """A user creates a new coin by remixing an existing one."""
    if original_coin_id not in self.coins:
        print(f"❌ Original coin '{original_coin_id}' not found.")
        return
    if remixer_name not in self.users:
        print(f"❌ User '{remixer_name}' not found.")
        return
    
    remixer = self.users[remixer_name]
    original_coin = self.coins[original_coin_id]
    
    # A remix is a form of minting, so it follows the same karma rules
    if not remixer.is_genesis and remixer.karma < remixer.next_mint_threshold:
        print(f"🔒 REMIX DENIED: {remixer_name} needs {remixer.next_mint_threshold:.0f} karma to mint (has {remixer.karma:.2f}).")
        return
        
    if not remixer.consent or not self.users[original_coin.root].consent:
        print("❌ Action denied. Both remixer and original creator must have consent.")
        return
    if not self.vaccine.scan(new_content):
        return

    # Create the new remixed coin
    new_coin_id = sha(f"{remixer_name}{new_content}{ts()}{random.random()}")
    new_coin = Coin(new_coin_id, root=original_coin.root, owner=remixer_name, tag=new_tag)
    new_coin.ancestry.append(original_coin_id)
    if references:
        new_coin.references = references
    
    self.coins[new_coin_id] = new_coin
    remixer.coins.append(new_coin_id)
    
    # Update minting threshold for non-genesis user
    if not remixer.is_genesis:
        remixer.mint_count += 1
        remixer.next_mint_threshold = max(100000.0 / (2 ** remixer.mint_count), 1000.0)

    # Award karma for the remix action itself
    base_value = self.emoji_weights.get("🔀", 4.0)
    self._award_karma(remixer_name, original_coin.root, base_value, "remix")

    self.log.add({"ts": ts(), "event": "REMIX", "details": f"{remixer_name} remixed {original_coin_id} into {new_coin_id}."})
    print(f"🔀 {remixer_name} successfully remixed '{original_coin_id}'. New coin: '{new_coin_id}'.")

def cite_reference(self, coin_id: str, username: str, reference: str):
    """Adds an external reference to a coin, logging the attribution."""
    if coin_id not in self.coins:
        print(f"❌ Coin '{coin_id}' not found.")
        return
    if username not in self.users:
        print(f"❌ User '{username}' not found.")
        return
    if not self.users[username].consent:
        print("❌ Action denied. User must have consent.")
        return
    if not self.vaccine.scan(reference):
        return
        
    self.coins[coin_id].references.append(reference)
    self.log.add({"ts": ts(), "event": "CITE_REFERENCE", "details": f"User {username} cited '{reference}' for coin {coin_id}."})
    print(f"📚 Reference added to coin '{coin_id}'.")

def get_stats(self):
    """Displays high-level statistics about the protocol state."""
    print("\n--- PROTOCOL STATISTICS ---")
    print(f"Total Users: {len(self.users)}")
    print(f"Total Coins: {len(self.coins)}")
    print(f"Community Treasury: {self.treasury:.4f} karma")
    print(f"Vaccine Blocks: {dict(self.vaccine.block_counts)}")
    print("\n--- LEADERBOARD (TOP 5 BY KARMA) ---")
    sorted_users = sorted(self.users.values(), key=lambda u: u.karma, reverse=True)
    for i, user in enumerate(sorted_users[:5]):
        print(f"{i+1}. {user.username}: {user.karma:.2f} karma")
    print("---------------------------\n")

def get_portfolio(self, username: str):
    """Displays the portfolio of a specific user."""
    if username not in self.users:
        print(f"❌ User '{username}' not found.")
        return
    user = self.users[username]
    print(f"\n--- PORTFOLIO: {username} ---")
    print(f"Karma: {user.karma:.2f}")
    print(f"Consent Status: {'Active' if user.consent else 'Inactive'}")
    if not user.is_genesis:
        print(f"Mints Completed: {user.mint_count}")
        print(f"Next Mint Threshold: {user.next_mint_threshold:.0f} karma")
    print(f"Coins Owned: {len(user.coins)}")
    for coin_id in user.coins:
        print(f"  - {coin_id}")
    print("---------------------------\n")

def save_snapshot(self, filepath: str = "remix_snapshot.json"):
    """Saves the entire state of the agent to a JSON file."""
    state = {
        "users": {uname: u.to_dict() for uname, u in self.users.items()},
        "coins": {cid: c.to_dict() for cid, c in self.coins.items()},
        "treasury": self.treasury,
        "log": list(self.log.entries)
    }
    try:
        with open(filepath, "w") as f:
            json.dump(state, f, indent=2)
        print(f"💾 Snapshot successfully saved to {filepath}")
    except IOError as e:
        print(f"❌ Error saving snapshot: {e}")

def load_snapshot(self, filepath: str = "remix_snapshot.json"):
    """Loads the agent state from a JSON file."""
    try:
        with open(filepath, "r") as f:
            state = json.load(f)
        
        # Reconstruct state
        self.users = {}
        for uname, u_data in state.get("users", {}).items():
            user = User(uname, u_data['is_genesis'], u_data['consent'])
            user.karma = u_data['karma']
            user.mint_count = u_data['mint_count']
            user.next_mint_threshold = u_data['next_mint_threshold']
            user.coins = u_data['coins']
            user.join_timestamp = u_data.get('join_timestamp', time.time())
            self.users[uname] = user

        self.coins = {}
        for cid, c_data in state.get("coins", {}).items():
            coin = Coin(c_data['id'], c_data['root'], c_data['owner'], c_data['value'], c_data['tag'])
            coin.ancestry = c_data['ancestry']
            coin.reactions = c_data['reactions']
            coin.references = c_data['references']
            self.coins[cid] = coin

        self.treasury = state.get("treasury", 0.0)
        
        self.log = LogChain()
        self.log.entries = deque(state.get("log",), maxlen=self.log.entries.maxlen)
        
        print(f"♻️ Snapshot successfully loaded from {filepath}")
    except FileNotFoundError:
        print(f"❓ Snapshot file not found at {filepath}")
    except (json.JSONDecodeError, KeyError) as e:
        print(f"❌ Error loading snapshot: Invalid file format. {e}")
------------------------------------------------------------------------------ONBOARDING QUIZ & COMMAND-LINE INTERFACE (CLI)------------------------------------------------------------------------------def onboarding_quiz() -> bool:"""An interactive quiz to ensure new users understand the core principles.Returns True if passed, False otherwise."""print("\n🤗 Welcome to the Remix Economy! First, a quick quiz on our core principles.")questions = [("What is the universal value split percentage for creators, contributors, and the treasury?", "33.3333"),("Is user consent required for all interactions? (yes/no)", "yes"),("What must every value-generating action be tagged with?", "emoji"),("Can new users mint content immediately upon joining? (yes/no)", "no"),("Is the protocol's history transparent and auditable? (yes/no)", "yes")]for q, a in questions:ans = input(f"👉 {q} ").strip().lower()if ans!= a:print("❌ Incorrect. Please review the protocol's Core Canons and try again.")return Falseprint("✅ Excellent! You understand the core canons. Welcome aboard!\n")return Truedef cli():"""The main Command-Line Interface for interacting with the Remix Agent."""agent = RemixAgent()corp_x = CorpX(agent.vaccine)print("🤖 Ultimate Remix Protocol Agent v6.0 Initialized.")
print("🧪 Sandbox mode active. Type ':help' for a list of commands.")

if not onboarding_quiz():
    return

while True:
    try:
        raw_input = input(">>> ").strip()
        if not raw_input:
            continue
        
        if raw_input.lower() in [':exit', ':quit']:
            print("🫶 Goodbye! Keep remixing!")
            break
        
        if not raw_input.startswith(':'):
            print("⚠️ Invalid command format. Commands must start with a colon ':'.")
            continue

        parts = raw_input[1:].split(maxsplit=2)
        command = parts.lower()
        args = parts[1:]

        if command == 'help':
            print("""
--- AVAILABLE COMMANDS ---
:adduser <name> [genesis][consent]  - Add a user. 'genesis' and 'consent' are optional flags.
:consent <name> <on|off>             - Set user consent.
:mint <name> <content> [tag][refs]  - Mint new content. Refs as comma-separated string.
:react <coin_id> <actor> <emoji>     - React to a coin.
:remix <orig_id> <remixer> <content> - Remix a coin.
:cite <coin_id> <user> <reference>   - Add a citation to a coin.
:stats                               - Show platform statistics and leaderboard.
:portfolio <name>                    - Show a user's portfolio.
:trace <coin_id>                     - Trace a coin's full history.
:log [filter]                        - Show the audit log.
:verify                              - Verify the logchain's integrity.
:attack [payload]                    - Simulate a CorpX attack.
:snap <save|load> [filepath]        - Save or load a system snapshot.
:exit / :quit                        - Exit the CLI.
            """)
        elif command == 'adduser':
            if len(args) < 1: print("Usage: :adduser <name> [genesis][consent]")
            else:
                is_gen = 'genesis' in args
                has_con = 'consent' in args
                agent.add_user(args, is_genesis=is_gen, consent=has_con)
        elif command == 'consent':
            if len(args)!= 2: print("Usage: :consent <name> <on|off>")
            else: agent.set_consent(args, args.lower() == 'on')
        elif command == 'mint':
            if len(args) < 2: print("Usage: :mint <name> <content> [tag][refs]")
            else:
                refs = args.split(',') if len(args) > 3 else None
                tag = args if len(args) > 2 and not args.startswith("ref") else "single"
                agent.mint(args, args, tag=tag, references=refs)
        elif command == 'react':
            if len(args)!= 3: print("Usage: :react <coin_id> <actor> <emoji>")
            else: agent.react(args, args, args)
        elif command == 'remix':
            if len(args)!= 3: print("Usage: :remix <orig_id> <remixer> <content>")
            else: agent.remix(args, args, args)
        elif command == 'cite':
            if len(args)!= 3: print("Usage: :cite <coin_id> <user> <reference>")
            else: agent.cite_reference(args, args, args)
        elif command == 'stats':
            agent.get_stats()
        elif command == 'portfolio':
            if len(args)!= 1: print("Usage: :portfolio <name>")
            else: agent.get_portfolio(args)
        elif command == 'trace':
            if len(args)!= 1: print("Usage: :trace <coin_id>")
            else: print("Feature not yet implemented.") # Placeholder
        elif command == 'log':
            filt = args if args else None
            agent.log.show(filt)
        elif command == 'verify':
            agent.log.verify()
        elif command == 'attack':
            payload = args if args else ""
            corp_x.attack(payload)
        elif command == 'snap':
            if len(args) < 1: print("Usage: :snap <save|load> [filepath]")
            else:
                filepath = args if len(args) > 1 else "remix_snapshot.json"
                if args == 'save': agent.save_snapshot(filepath)
                elif args == 'load': agent.load_snapshot(filepath)
        else:
            print(f"❓ Unknown command ':{command}'. Type ':help' for options.")

    except (EOFError, KeyboardInterrupt):
        print("\n🫶 Goodbye! Keep remixing!")
        break
    except Exception as e:
        print(f"💥 An unexpected error occurred: {e}. Please try again.")
if name == "main":cli()------------------------------------------------------------------------------EMBEDDED DELIVERABLES--------------------------------------------------------------------------------- To-Do List for the Future ---This list, synthesized from project documents, outlines the next steps for evolving the protocol.1.  Real-Time Emoji Market: Build a live analytics dashboard to visualize emojiusage, trends, and "market value" as a cultural pulse of the economy.12.  Personalized Creator Coins: Allow creators to mint their own unique, namedcoins and assign fractional values of them to their artworks, creating a moregranular and personal creator economy. 13.  Meme/Fork Lineage Engine: Develop a visual "family tree" or genealogy mapfor each coin to showcase the chain of remixes and celebrate creative lineage.14.  Automated Reference Audit & Cross-Credit: Integrate an AI module to suggestlikely citations for new content and automatically distribute karma to externalcreators if they join the platform later. 15.  Gamification & Challenges: Introduce streak bonuses, community challenges,and reputation badges to further incentivize consistent, high-qualitycollaboration. 16.  Advanced Governance Module: Implement the on-chain voting system forcommunity-led changes to emoji weights, protocol rules, and treasury spending.17.  Real-World Legal/Ethics Bridge: Draft and ratify a formal "expansionprotocol" detailing how to legally and ethically bridge the internal economyto real-world entities or tokens. 1--- Mind-Blowing LinkedIn Post ---LINKEDIN_POST = """🚀 We didn't just write a new app. We wrote a new economy. In one Python file.Introducing the Ultimate Remix Protocol—an open-source, emoji-powered universe where creativity is the only currency that matters.Forget everything you know about social media. Here, there are no hidden algorithms, no data exploitation, and no gatekeepers. There is only The Code.✨ How it works:Every like, comment, or remix is a real value event, transparently split 33.3333% between the original creator, the contributor, and the community treasury. It's all powered by emojis (🤗🔥🎨) and governed by radical consent.🛡️ Fairness by Design:Newcomers earn their place. You start by contributing and earning karma. Hit the 100k karma threshold, and you unlock the right to mint your own content. Each mint makes the next one easier, creating a fair path to becoming a core creator. We built in viral decay and diminishing returns to reward genuine collaboration, not spam.🔬 Credit Where Credit is Due:Inspired by a research paper? A piece of art? A meme? Cite it. Our protocol tracks the full lineage of every idea, ensuring that inspiration is always honored and rewarded.This isn't just a platform; it's a joyful, autonomous remix republic. A place where the code is the contract, and the community is the CEO. It's a living experiment in trust, collaboration, and what happens when you build an economy on gratitude.The entire protocol is on GitHub. Fork it. Break it. Improve it.The revolution will be remixed. 🫶#RemixEconomy #OpenSource #CreatorEconomy #EthicalTech #CodeIsLaw #EmojiProtocol #Decentralization #Web3 #Innovation"""
---

### **LinkedIn Post**

🚀 We didn't just write a new app. We wrote a new economy. In one Python file.

Introducing the **Ultimate Remix Protocol**—an open-source, emoji-powered universe where creativity is the only currency that matters.

Forget everything you know about social media. Here, there are no hidden algorithms, no data exploitation, and no gatekeepers. There is only **The Code.**

✨ **How it works:**
Every like, comment, or remix is a real value event, transparently split **33.3333%** between the original creator, the contributor, and the community treasury. It's all powered by emojis (🤗🔥🎨) and governed by radical consent.

🛡️ **Fairness by Design:**
Newcomers earn their place. You start by contributing and earning karma. Hit the 100k karma threshold, and you unlock the right to mint your own content. Each mint makes the next one easier, creating a fair path to becoming a core creator. We built in viral decay and diminishing returns to reward genuine collaboration, not spam.

🔬 **Credit Where Credit is Due:**
Inspired by a research paper? A piece of art? A meme? Cite it. Our protocol tracks the full lineage of every idea, ensuring that inspiration is always honored and rewarded.

This isn't just a platform; it's a **joyful, autonomous remix republic.** A place where the code is the contract, and the community is the CEO. It's a living experiment in trust, collaboration, and what happens when you build an economy on gratitude.

The entire protocol is on GitHub. Fork it. Break it. Improve it.

The revolution will be remixed. 🫶

#RemixEconomy #OpenSource #CreatorEconomy #EthicalTech #CodeIsLaw #EmojiProtocol #Decentralization #Web3 #Innovation


#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
🥰✨🎉 THE ULTIMATE KARMA-POWERED REMIX ECONOMY AGENT (README_8 Protocol)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
This is the canonical single-file protocol for the whateverOpenSourceUntitledCoLoL project.
It fully integrates and refines all prior logic into a definitive, production-ready agent.

This agent implements:
- Karma Gating & Exponential Onboarding: New users must earn karma to mint content.
  The threshold starts at 100,000 and halves with each successful mint, creating a
  fair but challenging path to full participation.
- Advanced Fairness Mechanics: A multi-layered system of diminishing returns (per-user,
  per-day) and viral decay (per-coin) prevents spam and ensures economic stability.
- Attribution-First Architecture: Enhanced data structures and hooks for tracking
  and rewarding external scientific and artistic references.
- Fortified Governance: A comprehensive, hash-chained audit log (`LogChain`), a
  modular content filter (`Vaccine`), and a rigorous consent framework.
- Extensibility: Designed with clear interfaces and placeholder hooks for future
  features, including advanced governance and the multi-species vision.
- The 33.3333% Split Law: The inviolable economic heart of the protocol, ensuring
  fair value distribution for every creative action.

This code is the contract. It is designed to be forked, remixed, and improved upon.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
"""

import re
import sys
import json
import random
import datetime
import hashlib
from collections import defaultdict, deque

# === UTILITY FUNCTIONS ===
def ts():
    """Returns the current UTC timestamp in ISO 8601 format."""
    return datetime.datetime.utcnow().isoformat() + "Z"

def sha(s):
    """Computes the SHA-256 hash of a given string."""
    return hashlib.sha256(s.encode()).hexdigest()

def today():
    """Returns the current date in YYYY-MM-DD format."""
    return datetime.date.today().isoformat()

# === IMMUNE SYSTEM (VACCINE) ===
# In a production environment, these patterns would be loaded from an external config file.
VAX_PATTERNS = {
    "critical": [r"\bhack\b", r"\bmalware\b", r"\bransomware\b", r"\bbackdoor\b"],
    "high":     [r"\bphish\b", r"\bddos\b", r"\bspyware\b", r"\brootkit\b"],
    "medium":   [r"\bpolitics\b", r"\bsurveillance\b", r"\bpropaganda\b", r"\bmanipulate\b"],
}
class Vaccine:
    """
    Scans content for forbidden patterns and blocks actions if found.
    Acts as the protocol's immune system against malicious content.
    """
    def __init__(self):
        self.block_counts = defaultdict(int)

    def scan(self, text):
        """
        Scans a text snippet. Returns False and logs the event if a forbidden
        pattern is found, otherwise returns True.
        """
        lower_text = text.lower()
        for level, patterns in VAX_PATTERNS.items():
            for p in patterns:
                if re.search(p, lower_text):
                    self.block_counts[level] += 1
                    # Log the blocked content for audit purposes.
                    with open("vaccine.log", "a") as f:
                        f.write(json.dumps({"ts": ts(), "severity": level, "pattern": p, "snippet": text[:88]}) + "\n")
                    print(f"🚫 VACCINE BLOCK [{level}]: Forbidden pattern '{p}' detected.")
                    return False
        return True

# === IMMUTABLE AUDIT LOG (LOGCHAIN) ===
class LogChain:
    """
    Implements an immutable, append-only audit log. Each entry is cryptographically
    chained to the previous one, ensuring a tamper-evident record of all events.
    """
    def __init__(self, filename="logchain.log", capacity=50000):
        self.filename = filename
        self.entries = deque(maxlen=capacity)
        try:
            with open(self.filename, "r") as f:
                for line in f:
                    self.entries.append(line.rstrip())
        except FileNotFoundError:
            pass

    def add(self, event):
        """Adds a new event (dict) to the log with a chained hash."""
        entry_json = json.dumps(event, sort_keys=True)
        prev_hash = self.entries[-1].split("||")[-1] if self.entries else ""
        # The new hash is a function of the new entry and the previous hash.
        chain_hash = sha(entry_json + prev_hash)
        self.entries.append(entry_json + "||" + chain_hash)
        self._save()

    def _save(self):
        """Writes the current log chain to the file."""
        with open(self.filename, "w") as fh:
            fh.write("\n".join(self.entries))

    def show(self, filter_str=None):
        """Displays log events, with an optional filter."""
        print("📜 AUDIT LOG:")
        count = 0
        for i, line in enumerate(self.entries, 1):
            if filter_str and filter_str.lower() not in line.lower():
                continue
            data = json.loads(line.split("||"))
            print(f"{i}. {data.get('ts','')} - {data.get('event','')}")
            count += 1
        if count == 0:
            print(" (no matching entries)")

    def verify(self):
        """Verifies the integrity of the entire logchain."""
        print("🔐 Verifying logchain integrity...")
        prev_hash = ""
        for idx, line in enumerate(self.entries, 1):
            try:
                entry, stored_hash = line.split("||")
            except ValueError:
                print(f"❌ CORRUPTION: Malformed log entry at line {idx}.")
                return False
            
            calculated_hash = sha(entry + prev_hash)
            if calculated_hash!= stored_hash:
                print(f"❌ TAMPER DETECTED: Chain break at entry {idx}. Hash mismatch.")
                return False
            prev_hash = stored_hash
        print("✅ Logchain integrity verified.")
        return True

# === CORE DATA MODELS ===
class User:
    """
    Represents a user in the protocol. This class encapsulates all user-specific
    state, including karma, consent, and minting status.
    """
    def __init__(self, name, is_genesis=False, consent=True):
        self.name = name
        self.is_genesis = is_genesis
        self.karma = 0.0
        self.consent = consent
        self.coins =
        self.minted_count = 0
        self.mint_threshold = 100000.0 if not is_genesis else 0.0
        self.daily_actions = defaultdict(int)
        self.last_action_date = today()

    def __repr__(self):
        return f"User(name='{self.name}', karma={self.karma:.2f}, is_genesis={self.is_genesis})"

class Coin:
    """
    Represents a unit of creative content (a "coin"). This class is enhanced to
    support the attribution-first framework.
    """
    def __init__(self, root, tag="single", value=1.0, ancestors=None, references=None, fields=None):
        self.root = root  # The original creator(s) of the content.
        self.tag = tag
        self.value = value
        self.ancestors = ancestors or  # List of parent coin IDs for remixes.
        self.references = references or  # Structured list of external attributions.
        self.fields = fields or  # Metadata tags (e.g., "science", "art").
        self.reactions =  # Log of (user, emoji, timestamp) tuples.

    def to_dict(self):
        """Serializes the coin object to a dictionary for logging or storage."""
        def fix_tuples(obj):
            if isinstance(obj, (list, tuple)):
                return [fix_tuples(x) for x in obj]
            return obj
        return {
            "root": fix_tuples(self.root),
            "tag": self.tag,
            "value": self.value,
            "ancestors": self.ancestors,
            "references": self.references,
            "fields": self.fields,
            "reactions": fix_tuples(self.reactions)
        }

# === THE ULTIMATE AGENT ===
class Agent:
    """
    The core protocol agent. It manages all users, coins, and economic interactions,
    and enforces the canonical laws of the system.
    """
    def __init__(self):
        self.log = LogChain()
        self.vaccine = Vaccine()
        self.users = {}
        self.coins = {}
        self.treasury = 0.0
        # Emoji weights determine the base value of reaction-based actions.
        self.weights = {"like": 1.0, "comment": 5.0, "remix": 10.0, "share": 2.0, "🤗": 5.0, "🎨": 3.0, "🔥": 2.0, "👍": 1.0, "👀": 0.5, "🙏": 10.0}
        self._initialize_genesis_users()
        self.log.add({"ts": ts(), "event": "PROTOCOL_INITIALIZED"})
        print("✅ Ultimate Karma Protocol Agent Initialized.")

    def _initialize_genesis_users(self):
        """Loads the predefined list of genesis collaborators."""
        nss_list = ["mimi", "taha", "platform"] + [f"nss_{i:02d}" for i in range(1, 48)]
        for name in nss_list:
            user = User(name, is_genesis=True, consent=True)
            user.karma = float('inf') # Genesis users have effectively infinite karma for minting.
            self.users[name] = user
        self.log.add({"ts": ts(), "event": f"GENESIS_USERS_INITIALIZED: {len(nss_list)} members"})

    def add_user(self, name, consent=True):
        """Adds a new, non-genesis user to the protocol."""
        if name in self.users:
            print(f"⚠️ User '{name}' already exists.")
            return
        user = User(name, is_genesis=False, consent=consent)
        self.users[name] = user
        self.log.add({"ts": ts(), "event": f"ADD_USER", "user": name, "consent": consent})
        print(f"👤 User '{name}' added to the protocol.")
        return user

    def set_consent(self, name, give=True):
        """Sets or revokes a user's consent to participate."""
        if name not in self.users:
            print(f"⚠️ Cannot set consent: User '{name}' not found.")
            return
        self.users[name].consent = bool(give)
        status = "GRANTED" if bool(give) else "REVOKED"
        self.log.add({"ts": ts(), "event": f"CONSENT_STATUS_CHANGED", "user": name, "status": status})
        print(f"Consent for {name}: {status}")

    def _reset_daily_counters(self, user):
        """Resets a user's daily action counters if a new day has begun."""
        current_day = today()
        if user.last_action_date!= current_day:
            user.daily_actions.clear()
            user.last_action_date = current_day

    def _award_karma(self, actor_name, origin_name, base_value, action_type):
        """
        Centralized function for calculating and distributing karma according to the
        33.3333% split law and applying fairness mechanics.
        """
        actor = self.users[actor_name]
        origin = self.users[origin_name]

        # 1. Apply daily diminishing returns for the actor.
        self._reset_daily_counters(actor)
        action_count = actor.daily_actions[action_type]
        daily_decay_factor = 0.9 ** action_count
        effective_value = base_value * daily_decay_factor

        # 2. Calculate shares based on the 33% split law.
        share = round(effective_value / 3.0, 6)

        # 3. Distribute karma.
        actor.karma += share
        origin.karma += share
        self.treasury += share
        
        actor.daily_actions[action_type] += 1
        return share

    def mint(self, user_name, content, tag="single", references=None, fields=None):
        """
        Allows a user to mint a new coin, subject to permissions and karma thresholds.
        """
        if user_name not in self.users:
            print(f"⚠️ Mint failed: User '{user_name}' not found.")
            return None

        user = self.users[user_name]
        if not user.consent:
            print(f"❌ Mint denied: User '{user_name}' has not granted consent.")
            return None
        if not self.vaccine.scan(content):
            return None
        
        # Check for science/art attribution requirement.
        if fields and ("science" in fields or "art" in fields) and not references:
            print("❌ Mint denied: Posts tagged as 'science' or 'art' require references.")
            return None

        # Check if user has the right to mint.
        if not user.is_genesis:
            if user.karma < user.mint_threshold:
                needed = user.mint_threshold - user.karma
                print(f"🔒 Mint denied: {user_name} needs {needed:.2f} more karma (has {user.karma:.2f}, needs {user.mint_threshold:.2f}).")
                return None
            # Halve the threshold for the next mint.
            user.mint_threshold = max(user.mint_threshold / 2.0, 1000.0)

        # Create and log the new coin.
        coin_id = sha(f"{user_name}{ts()}{content}{random.random()}")
        coin = Coin(root=user_name, tag=tag, references=references, fields=fields)
        self.coins[coin_id] = coin
        user.coins.append(coin_id)
        user.minted_count += 1

        self.log.add({"ts": ts(), "event": "MINT", "user": user_name, "coin_id": coin_id, "tag": tag, "content": content[:60]})
        print(f"🪙 Coin '{coin_id}' minted by {user_name}.")
        return coin_id

    def react(self, actor_name, coin_id, emoji):
        """
        Allows a user to react to a coin, triggering a karma distribution.
        """
        if actor_name not in self.users or coin_id not in self.coins:
            print("⚠️ React failed: Invalid user or coin.")
            return
        
        actor = self.users[actor_name]
        coin = self.coins[coin_id]
        origin_name = coin.root

        if not actor.consent or not self.users[origin_name].consent:
            print("❌ React denied: Consent required from both actor and originator.")
            return
        
        base_value = self.weights.get(emoji, 1.0)
        
        # Apply viral decay based on the number of existing reactions.
        viral_decay_factor = 0.95 ** len(coin.reactions)
        effective_base_value = base_value * viral_decay_factor

        share = self._award_karma(actor_name, origin_name, effective_base_value, f"react_{emoji}")
        
        coin.reactions.append((actor_name, emoji, ts()))
        self.log.add({"ts": ts(), "event": "REACT", "actor": actor_name, "coin_id": coin_id, "emoji": emoji, "karma_share": share})
        print(f"{emoji} {actor_name} reacted to '{coin_id}'. Karma share: {share:.4f} each to actor, origin, and treasury.")

    def remix(self, actor_name, parent_coin_id, new_content, new_tag="remix", references=None, fields=None):
        """
        Allows a user to create a derivative coin (remix), preserving lineage.
        """
        if parent_coin_id not in self.coins:
            print(f"⚠️ Remix failed: Parent coin '{parent_coin_id}' not found.")
            return None
        
        # Minting a remix is subject to the same rules as minting an original post.
        new_coin_id = self.mint(actor_name, new_content, tag=new_tag, references=references, fields=fields)

        if new_coin_id:
            parent_coin = self.coins[parent_coin_id]
            new_coin = self.coins[new_coin_id]
            new_coin.ancestors.append(parent_coin_id)
            
            # Award karma for the remix action itself.
            origin_name = parent_coin.root
            base_value = self.weights.get("remix", 10.0)
            share = self._award_karma(actor_name, origin_name, base_value, "remix")

            self.log.add({"ts": ts(), "event": "REMIX", "actor": actor_name, "parent_coin": parent_coin_id, "new_coin": new_coin_id, "karma_share": share})
            print(f"🔀 '{actor_name}' remixed '{parent_coin_id}' into '{new_coin_id}'. Karma share: {share:.4f} each.")
        return new_coin_id

    # --- Placeholder Hooks for Future Features ---
    def process_unclaimed_references(self):
        """
        Architectural hook for the future "Cross-Credit System". This function would
        periodically scan for references linked to newly verified users and distribute
        retroactive credit.
        """
        self.log.add({"ts": ts(), "event": "HOOK_CALLED", "name": "process_unclaimed_references"})
        # Placeholder logic
        pass

    def trigger_governance_vote(self, proposal):
        """
        Architectural hook for the future "Emoji Canon Voting Layer". This would
        initiate a community vote on a proposed change to the protocol.
        """
        self.log.add({"ts": ts(), "event": "HOOK_CALLED", "name": "trigger_governance_vote", "proposal": proposal})
        # Placeholder logic
        pass

    def show_stats(self):
        """Displays summary statistics for the protocol."""
        print("\n--- PROTOCOL STATISTICS ---")
        print(f"Total Users: {len(self.users)}")
        print(f"Total Coins: {len(self.coins)}")
        print(f"Treasury Balance: {self.treasury:.4f} karma")
        
        print("\n--- LEADERBOARD (TOP 5 by KARMA) ---")
        # Filter out genesis users who have infinite karma for a meaningful leaderboard.
        non_genesis_users = {u.name: u.karma for u in self.users.values() if not u.is_genesis}
        if non_genesis_users:
            leaderboard = sorted(non_genesis_users.items(), key=lambda item: item, reverse=True)
            for i, (name, karma) in enumerate(leaderboard[:5], 1):
                print(f"{i}. {name}: {karma:.2f} karma")
        else:
            print(" (No non-genesis users to rank)")
        print("---------------------------\n")

