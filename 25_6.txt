# -------------------------------------------------------------------------------
# The Emoji Engine â€” MetaKarma Hub Ultimate Mega-Agent v5.16+
#
# Copyright (c) 2023-2026 mimi, taha & supernova
#
# Powered by humans & machines hand in hand â€” remixing creativity, karma & cosmos.
# Special shoutout to Gemini, Google Gemini, OpenAI GPT & Anthropic Cloud
# â€” the stellar trio that helped spark this cosmic project ðŸš€âœ¨
#
# MIT License â€” remix, fork, evolve, connect your universe.
# -------------------------------------------------------------------------------

"""
Welcome to MetaKarma Hub! ðŸŒŒâœ¨ðŸŽ®

The ultimate legoblock core for building boundless multiverses â€” each a remix republic shaped by you.

ðŸ§© Modular, scalable, immutable, and open.

Every citizen starts with one root coin â€” the spark of creation ðŸ”¥,
whether human or decentralized AI agent, each with independent karma potential.

Mint fractional coins as legos to remix, improve, and innovate endlessly.
Trade fractional ownership on a marketplace to monetize your remix republic.

Reactions flow coin value through cosmic veins,
shared fairly between original creators, reactors (interactors), and treasury â€” communal light ðŸ’Ž.

Karma is a separate reputation currency unlocking minting and voting power.

Governance is truly multi-species: humans, AI, others,
each voice equal by default,
with voting weights dynamically normalized:
- Two species: 50/50 split
- Three or more: evenly split (~33% each)
Super-majority approval threshold is set to 70% to encourage meaningful consensus.

Value exchange flows through emojis, amplifying social influence and economic dynamics without politics.

The Vaccine adapts, blocking evolving threats ðŸ›¡ï¸ with governance-overseen pattern updates.

Hooks plug into Discord, Unreal, AI agents â€” you name it. Play on.

No politics, no divisiveness. Pure remix magic.

Join us. Remix reality. Build universes.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"""

import sys
import json
import uuid
import datetime
import hashlib
import threading
import base64
import re
import logging
import time
from collections import defaultdict, deque
from decimal import Decimal, getcontext, InvalidOperation
from typing import Optional, Dict, List, Any, Callable

getcontext().prec = 28
logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s: %(message)s')


def acquire_agent_lock(func):
    def wrapper(self, *args, **kwargs):
        with self.lock:
            return func(self, *args, **kwargs)
    return wrapper


class Config:
    _lock = threading.RLock()
    VERSION = "EmojiEngine UltimateMegaAgent v5.16+"

    GENESIS_COIN_INITIAL_VALUE = Decimal('1E6')
    FRACTIONAL_COIN_MIN_VALUE = Decimal('1000')
    GENESIS_FADE_YEARS = Decimal('10')
    GENESIS_MULTIPLIER = Decimal('2')
    DAILY_DECAY = Decimal('0.99')
    VIRAL_DECAY = Decimal('0.95')
    TREASURY_SHARE = Decimal('0.3333333333333333333333333333')
    TREASURY_ACTIVE_ALLOCATION_PCT = Decimal('0.02')
    MARKET_FEE = Decimal('0.01')
    MAX_FRACTION_START = Decimal('0.10')
    MAX_FRACTION_MAX = Decimal('0.30')
    MAX_LOG = 150_000
    MAX_MINTS_PER_DAY = 5
    MAX_REACTS_PER_MINUTE = 30
    MIN_IMPROVEMENT_LEN = 15
    GOV_SUPERMAJORITY_THRESHOLD = Decimal('0.70')
    NETWORK_BONUS_EXPONENT = Decimal('0.5')
    PROPOSAL_VOTE_DURATION_HOURS = 72
    KARMA_MINT_THRESHOLD = Decimal('200000')

    VAX_PATTERNS = {
        "critical": [r"\bhack\b", r"\bmalware\b", r"\bransomware\b", r"\bbackdoor\b", r"\bexploit\b"],
        "high": [r"\bphish\b", r"\bddos\b", r"\bspyware\b", r"\brootkit\b", r"\bkeylogger\b", r"\bbotnet\b"],
        "medium": [r"\bpropaganda\b", r"\bsurveillance\b", r"\bmanipulate\b"],
        "low": [r"\bspam\b", r"\bscam\b", r"\bviagra\b"],
    }

    EMOJI_BASE = {
        "ðŸ¤—": Decimal('7'), "ðŸ¥°": Decimal('5'), "ðŸ˜": Decimal('5'), "ðŸ”¥": Decimal('4'),
        "ðŸ«¶": Decimal('4'), "ðŸŒ¸": Decimal('3'), "ðŸ’¯": Decimal('3'), "ðŸŽ‰": Decimal('3'),
        "âœ¨": Decimal('3'), "ðŸ™Œ": Decimal('3'), "ðŸŽ¨": Decimal('3'), "ðŸ’¬": Decimal('3'),
        "ðŸ‘": Decimal('2'), "ðŸš€": Decimal('2.5'), "ðŸ’Ž": Decimal('6'), "ðŸŒŸ": Decimal('3'),
        "âš¡": Decimal('2.5'), "ðŸ‘€": Decimal('0.5'), "ðŸ¥²": Decimal('0.2'), "ðŸ¤·â€â™‚ï¸": Decimal('2'),
        "ðŸ˜…": Decimal('2'), "ðŸ”€": Decimal('4'), "ðŸ†•": Decimal('3'), "ðŸ”—": Decimal('2'), "â¤ï¸": Decimal('4'),
    }

    ALLOWED_POLICY_KEYS = {
        "MARKET_FEE": lambda v: Decimal(v) >= 0 and Decimal(v) <= Decimal('0.10'),
        "DAILY_DECAY": lambda v: Decimal('0.90') <= Decimal(v) <= Decimal('1'),
        "KARMA_MINT_THRESHOLD": lambda v: Decimal(v) >= 0,
    }

    @classmethod
    def update_policy(cls, key: str, value: Any):
        with cls._lock:
            if key not in cls.ALLOWED_POLICY_KEYS:
                raise InvalidInputError(f"Policy key '{key}' not allowed")
            if not cls.ALLOWED_POLICY_KEYS[key](value):
                raise InvalidInputError(f"Policy value '{value}' invalid for key '{key}'")
            setattr(cls, key, Decimal(value))
            logging.info(f"Policy '{key}' updated to {value}")


def now_utc() -> datetime.datetime:
    return datetime.datetime.now(datetime.timezone.utc)


def ts() -> str:
    return now_utc().isoformat()


def sha(data: str) -> str:
    return base64.b64encode(hashlib.sha256(data.encode('utf-8')).digest()).decode()


def today() -> str:
    return now_utc().date().isoformat()


def safe_divide(a: Decimal, b: Decimal, default=Decimal('0')) -> Decimal:
    try:
        return a / b if b != 0 else default
    except (InvalidOperation, ZeroDivisionError):
        return default


def is_valid_username(name: str) -> bool:
    return bool(re.fullmatch(r'[A-Za-z0-9_]{3,30}', name))


def is_valid_emoji(emoji: str) -> bool:
    return emoji in Config.EMOJI_BASE


# Exception Classes
class UserExistsError(Exception): pass
class ConsentError(Exception): pass
class KarmaError(Exception): pass
class BlockedContentError(Exception): pass
class CoinDepletedError(Exception): pass
class RateLimitError(Exception): pass
class ImprovementRequiredError(Exception): pass
class EmojiRequiredError(Exception): pass
class TradeError(Exception): pass
class VoteError(Exception): pass
class InvalidInputError(Exception): pass
class RootCoinMissingError(InvalidInputError): pass
class InsufficientFundsError(Exception): pass
class InvalidPercentageError(Exception): pass


class Vaccine:
    def __init__(self):
        self.lock = threading.RLock()
        self.block_counts = defaultdict(int)
        self.compiled_patterns = {}
        for lvl, pats in Config.VAX_PATTERNS.items():
            compiled = []
            for p in pats:
                try:
                    compiled.append(re.compile(p))
                except re.error as e:
                    logging.error(f"Invalid regex '{p}' level '{lvl}': {e}")
            self.compiled_patterns[lvl] = compiled

    def scan(self, text: str) -> bool:
        if not isinstance(text, str):
            return True
        t = text.lower()
        with self.lock:
            for lvl, pats in self.compiled_patterns.items():
                for pat in pats:
                    if pat.search(t):
                        self.block_counts[lvl] += 1
                        try:
                            with open("vaccine.log", "a", encoding="utf-8") as f:
                                f.write(json.dumps({
                                    "ts": ts(),
                                    "nonce": uuid.uuid4().hex,
                                    "level": lvl,
                                    "pattern": pat.pattern,
                                    "snippet": text[:80]
                                }) + "\n")
                        except (FileNotFoundError, PermissionError) as e:
                            logging.error(f"File error writing vaccine.log: {e}")
                        except Exception as e:
                            logging.error(f"Unexpected error writing vaccine.log: {e}")
                        logging.warning(f"Vaccine blocked '{pat.pattern}' level '{lvl}': '{text[:50]}...'")
                        return False
        return True


class LogChain:
    def __init__(self, filename="logchain.log", maxlen=Config.MAX_LOG):
        self.filename = filename
        self.lock = threading.RLock()
        self.entries = deque(maxlen=maxlen)
        self._load()

    def _load(self):
        try:
            with open(self.filename, "r", encoding="utf-8") as f:
                for line in f:
                    self.entries.append(line.strip())
            logging.info(f"Loaded {len(self.entries)} audit entries")
        except FileNotFoundError:
            logging.info("No audit log found, starting fresh")

    def add(self, event: Dict[str, Any]) -> None:
        event["nonce"] = uuid.uuid4().hex
        event["timestamp"] = ts()
        json_event = json.dumps(event, sort_keys=True, default=str)
        with self.lock:
            prev_hash = self.entries[-1].split("||")[-1] if self.entries else ""
            new_hash = sha(prev_hash + json_event)
            entry_line = json_event + "||" + new_hash
            self.entries.append(entry_line)
            try:
                with open(self.filename, "a", encoding="utf-8") as f:
                    f.write(entry_line + "\n")
                    f.flush()
            except IOError as e:
                logging.error(f"Failed to write audit log: {e}")

    def verify(self) -> bool:
        prev_hash = ""
        for line in self.entries:
            try:
                event_json, h = line.split("||")
            except ValueError:
                logging.error("Malformed audit log line")
                return False
            if sha(prev_hash + event_json) != h:
                logging.error("Audit log hash mismatch")
                return False
            prev_hash = h
        return True


class User:
    def __init__(self, name: str, genesis: bool = False, species: str = "human"):
        self.name = name
        self.is_genesis = genesis
        self.species = species
        self.consent = True
        self.karma = Decimal('0')
        self.join_time = now_utc()
        self.last_active = self.join_time
        self.mint_count = 0
        self.next_mint_threshold = Config.KARMA_MINT_THRESHOLD
        self.root_coin_id: Optional[str] = None
        self.coins_owned: List[str] = []
        self.daily_actions: Dict[str, Dict[str, int]] = defaultdict(lambda: defaultdict(int))
        self._last_action_day: Optional[str] = today()
        self._reaction_timestamps: deque = deque()
        self.lock = threading.RLock()
        self.initial_root_value: Optional[Decimal] = None

    def add_karma(self, amount: Decimal):
        with self.lock:
            self.karma += amount

    def reset_daily_if_needed(self):
        today_str = today()
        with self.lock:
            if self._last_action_day != today_str:
                self.daily_actions.clear()
                self._last_action_day = today_str
                self._reaction_timestamps.clear()

    def check_reaction_rate_limit(self) -> bool:
        now_ts = now_utc().timestamp()
        with self.lock:
            while self._reaction_timestamps and now_ts - self._reaction_timestamps[0] > 60:
                self._reaction_timestamps.popleft()
            if len(self._reaction_timestamps) >= Config.MAX_REACTS_PER_MINUTE:
                return False
            self._reaction_timestamps.append(now_ts)
            return True

    def check_mint_rate_limit(self) -> bool:
        self.reset_daily_if_needed()
        with self.lock:
            return self.daily_actions[today()].get("mint", 0) < Config.MAX_MINTS_PER_DAY

    def apply_daily_karma_decay(self):
        now_dt = now_utc()
        inactive_days = (now_dt - self.last_active).days
        if inactive_days > 7:
            decay_factor = Config.DAILY_DECAY ** (inactive_days - 7)
            with self.lock:
                old_karma = self.karma
                self.karma *= decay_factor
                if old_karma != self.karma:
                    logging.info(f"Applied karma decay to user {self.name}: {old_karma} -> {self.karma}")

    def to_dict(self):
        with self.lock:
            return {
                "name": self.name,
                "is_genesis": self.is_genesis,
                "species": self.species,
                "consent": self.consent,
                "karma": str(self.karma),
                "join_time": self.join_time.isoformat(),
                "last_active": self.last_active.isoformat(),
                "mint_count": self.mint_count,
                "next_mint_threshold": str(self.next_mint_threshold),
                "root_coin_id": self.root_coin_id,
                "coins_owned": self.coins_owned[:],
                "daily_actions": {k: dict(v) for k, v in self.daily_actions.items()},
                "_last_action_day": self._last_action_day,
                "_reaction_timestamps": list(self._reaction_timestamps),
                "initial_root_value": str(self.initial_root_value) if self.initial_root_value else None,
            }

    @classmethod
    def from_dict(cls, data):
        user = cls(data["name"], data.get("is_genesis", False), data.get("species", "human"))
        user.consent = data.get("consent", True)
        user.karma = Decimal(data.get("karma", '0'))
        user.join_time = datetime.datetime.fromisoformat(data.get("join_time"))
        user.last_active = datetime.datetime.fromisoformat(data.get("last_active"))
        user.mint_count = data.get("mint_count", 0)
        user.next_mint_threshold = Decimal(data.get("next_mint_threshold", Config.KARMA_MINT_THRESHOLD))
        user.root_coin_id = data.get("root_coin_id")
        user.coins_owned = data.get("coins_owned", [])
        user.daily_actions = defaultdict(lambda: defaultdict(int), {k: defaultdict(int, v) for k, v in data.get("daily_actions", {}).items()})
        user._last_action_day = data.get("_last_action_day", today())
        user._reaction_timestamps = deque(data.get("_reaction_timestamps", []))
        user.initial_root_value = Decimal(data.get("initial_root_value")) if data.get("initial_root_value") else None
        return user


class Coin:
    def __init__(self, coin_id: str, creator: str, owner: str, value: Decimal,
                 is_root: bool = False, fractional_of: Optional[str] = None,
                 fractional_pct: Decimal = Decimal('0'), references: Optional[List[Dict]] = None,
                 improvement: Optional[str] = None, genesis_creator: Optional[str] = None):
        self.coin_id = coin_id
        self.creator = creator
        self.owner = owner
        self.value = value
        self.is_root = is_root
        self.fractional_of = fractional_of
        self.fractional_pct = fractional_pct
        self.references = references or []
        self.improvement = improvement or ""
        self.ancestors: List[str] = []
        self.reactions: List[Dict] = []
        self.created_at = ts()
        self.genesis_creator = genesis_creator or (creator if is_root else None)

    def decrease_value(self, amount: Decimal):
        if self.value < amount:
            raise CoinDepletedError(f"Coin {self.coin_id} value depleted by {amount}")
        self.value -= amount

    def to_dict(self):
        return {
            "coin_id": self.coin_id,
            "creator": self.creator,
            "owner": self.owner,
            "value": str(self.value),
            "is_root": self.is_root,
            "fractional_of": self.fractional_of,
            "fractional_pct": str(self.fractional_pct),
            "references": self.references,
            "improvement": self.improvement,
            "ancestors": self.ancestors[:],
            "reactions": self.reactions[:],
            "created_at": self.created_at,
            "genesis_creator": self.genesis_creator,
        }

    @classmethod
    def from_dict(cls, data):
        coin = cls(
            data["coin_id"], data["creator"], data["owner"], Decimal(data["value"]),
            data.get("is_root", False), data.get("fractional_of"), Decimal(data.get("fractional_pct", '0')),
            data.get("references"), data.get("improvement"), data.get("genesis_creator")
        )
        coin.ancestors = data.get("ancestors", [])
        coin.reactions = data.get("reactions", [])
        coin.created_at = data.get("created_at", ts())
        return coin


class EmojiMarket:
    def __init__(self):
        self.lock = threading.RLock()
        self.market = {e: {"uses": Decimal('1'), "karma": Decimal(w), "weight": Decimal(w)} for e, w in Config.EMOJI_BASE.items()}

    def update_weight(self, emoji: str, karma_delta: Decimal):
        with self.lock:
            em = self.market.setdefault(emoji, {"uses": Decimal('0'), "karma": Decimal('0'), "weight": Decimal('1')})
            em["uses"] += 1
            em["karma"] += karma_delta
            alpha = Decimal('0.1')
            em["weight"] = alpha * (em["karma"] / em["uses"]) + (Decimal('1') - alpha) * em["weight"]

    def get_weight(self, emoji: str) -> Decimal:
        with self.lock:
            return self.market.get(emoji, {"weight": Decimal('1')})["weight"]

    def to_dict(self):
        with self.lock:
            return {e: {k: str(v) if isinstance(v, Decimal) else v for k, v in val.items()} for e, val in self.market.items()}

    @classmethod
    def from_dict(cls, data):
        em = cls()
        with em.lock:
            em.market = {e: {k: Decimal(v) if k != 'weight' else v for k, v in val.items()} for e, val in data.items()}
        return em


class HookManager:
    def __init__(self):
        self._hooks = defaultdict(list)
        self.lock = threading.RLock()

    def register_hook(self, event_name: str, callback: Callable):
        with self.lock:
            self._hooks[event_name].append(callback)
            logging.info(f"Hook registered for event '{event_name}'")

    def fire_hooks(self, event_name: str, *args, **kwargs):
        with self.lock:
            callbacks = list(self._hooks.get(event_name, []))
        for cb in callbacks:
            try:
                cb(*args, **kwargs)
            except Exception as e:
                logging.error(f"Error in hook '{event_name}': {e}")


class Proposal:
    def __init__(self, proposal_id: str, creator: str, description: str, target: str, payload: dict):
        self.proposal_id = proposal_id
        self.creator = creator
        self.description = description
        self.target = target
        self.payload = payload
        self.created_at = ts()
        self.votes = {}
        self.status = "open"

    def is_expired(self) -> bool:
        created_dt = datetime.datetime.fromisoformat(self.created_at)
        return (now_utc() - created_dt).total_seconds() > Config.PROPOSAL_VOTE_DURATION_HOURS * 3600

    def tally_votes(self, users: Dict[str, User]) -> Dict[str, Decimal]:
        species_count = defaultdict(set)
        for uname in self.votes:
            user = users.get(uname)
            if user:
                species_count[user.species].add(uname)

        total_species = len(species_count)
        if total_species == 0:
            return {"yes": Decimal('0'), "no": Decimal('0'), "total": Decimal('0')}

        species_weight = {s: Decimal('1') / Decimal(total_species) for s in species_count}
        yes_weight = Decimal('0')
        no_weight = Decimal('0')

        for species, voters in species_count.items():
            karma_yes = Decimal('0')
            karma_no = Decimal('0')
            total_karma = sum(users[v].karma for v in voters) or Decimal('1')

            for v in voters:
                vote = self.votes.get(v)
                if vote == "yes":
                    karma_yes += users[v].karma
                elif vote == "no":
                    karma_no += users[v].karma

            yes_weight += species_weight[species] * (karma_yes / total_karma)
            no_weight += species_weight[species] * (karma_no / total_karma)

        total_votes = yes_weight + no_weight
        return {"yes": yes_weight, "no": no_weight, "total": total_votes}

    def is_approved(self, users: Dict[str, User]) -> bool:
        tally = self.tally_votes(users)
        if tally["total"] == 0:
            return False
        return tally["yes"] / tally["total"] >= Config.GOV_SUPERMAJORITY_THRESHOLD

    def to_dict(self):
        return {
            "proposal_id": self.proposal_id,
            "creator": self.creator,
            "description": self.description,
            "target": self.target,
            "payload": self.payload,
            "created_at": self.created_at,
            "votes": self.votes.copy(),
            "status": self.status,
        }

    @classmethod
    def from_dict(cls, data):
        proposal = cls(
            data["proposal_id"], data["creator"], data["description"], data["target"], data["payload"]
        )
        proposal.created_at = data.get("created_at", ts())
        proposal.votes = data.get("votes", {})
        proposal.status = data.get("status", "open")
        return proposal


class RemixAgent:
    def __init__(self, snapshot_file: str = "snapshot.json", logchain_file: str = "logchain.log"):
        self.vaccine = Vaccine()
        self.logchain = LogChain(filename=logchain_file)
        self.users: Dict[str, User] = {}
        self.coins: Dict[str, Coin] = {}
        self.proposals: Dict[str, Proposal] = {}
        self.treasury = Decimal('0')
        self.treasury_active_fund = Decimal('0')
        self.emoji_market = EmojiMarket()
        self.hooks = HookManager()
        self.lock = threading.RLock()
        self.snapshot_file = snapshot_file
        self._last_decay_day: Optional[str] = None
        self._last_proposal_check: Optional[datetime.datetime] = None
        self.marketplace_listings: Dict[str, Dict[str, Any]] = {}
        self.load_state()

    # Core internal operations, not exposed publicly, no validation here:
    def _do_add_user(self, name, is_genesis, species, karma, join_time, last_active, root_coin_id, coins_owned, initial_root_value, consent, root_coin_value):
        user = User(name, is_genesis, species)
        user.consent = consent
        user.karma = karma
        user.join_time = join_time
        user.last_active = last_active
        user.root_coin_id = root_coin_id
        user.coins_owned = coins_owned
        user.initial_root_value = initial_root_value
        self.users[name] = user
        coin = Coin(root_coin_id, name, name, root_coin_value, True, genesis_creator=name)
        self.coins[root_coin_id] = coin

    def _do_mint_coin(self, user_name, new_coin_id, mint_value, new_coin_value,
                      root_coin_id, genesis_creator, references,
                      improvement, fractional_pct, ancestors, created_at):
        user = self.users[user_name]
        root_coin = self.coins[root_coin_id]
        new_coin = Coin(
            coin_id=new_coin_id,
            creator=root_coin.creator,
            owner=user_name,
            value=new_coin_value,
            is_root=False,
            fractional_of=root_coin_id,
            fractional_pct=fractional_pct,
            references=references,
            improvement=improvement,
            genesis_creator=genesis_creator
        )
        new_coin.ancestors = ancestors
        new_coin.created_at = created_at
        self.coins[new_coin_id] = new_coin
        root_coin.value -= mint_value
        split_value = mint_value * Config.TREASURY_SHARE
        creator_user = self.users.get(genesis_creator)
        if creator_user and creator_user.root_coin_id and creator_user.root_coin_id in self.coins:
            creator_root_coin = self.coins[creator_user.root_coin_id]
            creator_root_coin.value += split_value
        else:
            root_coin.value += split_value
        self.treasury += split_value
        user.coins_owned.append(new_coin_id)
        user.mint_count += 1
        user.next_mint_threshold = max(user.next_mint_threshold / 2, Config.FRACTIONAL_COIN_MIN_VALUE)
        user.last_active = datetime.datetime.fromisoformat(created_at)

    def _do_react_to_coin(self, reactor, coin_id, emoji, message,
                          coin_value_reactor, coin_value_creator,
                          coin_value_treasury, viral_decay, emoji_weight_used,
                          network_bonus, decay_factor_used, timestamp):
        reactor_user = self.users[reactor]
        coin = self.coins[coin_id]
        self.emoji_market.update_weight(emoji, coin_value_creator)
        coin.reactions.append({"reactor": reactor, "emoji": emoji, "message": message, "timestamp": timestamp})
        reactor_user.last_active = datetime.datetime.fromisoformat(timestamp)
        user_root_coin = self.coins.get(reactor_user.root_coin_id)
        if user_root_coin:
            user_root_coin.value += coin_value_reactor
        else:
            coin.value += coin_value_reactor
        creator_user = self.users.get(coin.genesis_creator)
        if creator_user and creator_user.root_coin_id and creator_user.root_coin_id in self.coins:
            creator_coin = self.coins[creator_user.root_coin_id]
            creator_coin.value += coin_value_creator
        else:
            coin.value += coin_value_creator
        self.treasury += coin_value_treasury

    def _do_list_coin_for_sale(self, listing_id, seller, coin_id, price, created_at):
        self.marketplace_listings[listing_id] = {
            "listing_id": listing_id,
            "seller": seller,
            "coin_id": coin_id,
            "price": price,
            "status": "active",
            "created_at": created_at,
        }

    def _do_buy_coin(self, buyer, seller, coin_id, price, fee_amount, listing_id, sold_at):
        buyer_user = self.users[buyer]
        seller_user = self.users[seller]
        coin = self.coins[coin_id]
        buyer_root_coin = self.coins[buyer_user.root_coin_id]
        buyer_root_coin.value -= (price + fee_amount)
        seller_root_coin = self.coins[seller_user.root_coin_id]
        seller_root_coin.value += price
        self.treasury += fee_amount
        coin.owner = buyer
        if coin_id in seller_user.coins_owned:
            seller_user.coins_owned.remove(coin_id)
        if coin_id not in buyer_user.coins_owned:
            buyer_user.coins_owned.append(coin_id)
        listing = self.marketplace_listings[listing_id]
        listing["status"] = "sold"
        listing["buyer"] = buyer
        listing["sold_at"] = sold_at

    def _do_transfer_coin(self, from_user, to_user, coin_id):
        sender = self.users[from_user]
        receiver = self.users[to_user]
        coin = self.coins[coin_id]
        coin.owner = to_user
        if coin_id in sender.coins_owned:
            sender.coins_owned.remove(coin_id)
        if coin_id not in receiver.coins_owned:
            receiver.coins_owned.append(coin_id)

    def _do_create_proposal(self, proposal_id, creator, description, target, payload, created_at):
        proposal = Proposal(proposal_id, creator, description, target, payload)
        proposal.created_at = created_at
        self.proposals[proposal_id] = proposal

    def _do_vote_proposal(self, proposal_id, voter, vote):
        proposal = self.proposals[proposal_id]
        proposal.votes[voter] = vote

    def _do_execute_proposal(self, proposal_id):
        proposal = self.proposals[proposal_id]
        proposal.status = "executed"
        # Implement policy change or other side effects here if needed
        # For example, update Config from proposal.payload if applicable

    def _do_close_proposal(self, proposal_id, status):
        proposal = self.proposals[proposal_id]
        proposal.status = status

    def _do_daily_decay(self, treasury_allocation, timestamp):
        self.treasury -= treasury_allocation
        self.treasury_active_fund += treasury_allocation
        self._last_decay_day = datetime.datetime.fromisoformat(timestamp).date().isoformat()

    # Public API methods applying log-first-then-apply event sourcing:

    @acquire_agent_lock
    def add_user(self, name: str, genesis: bool = False, species: str = "human") -> User:
        if not is_valid_username(name):
            raise InvalidInputError(f"Invalid username format: '{name}'")
        if name in self.users:
            raise UserExistsError(f"User '{name}' exists")

        # Compose event
        coin_id = uuid.uuid4().hex
        join_time = now_utc()
        root_value = Config.GENESIS_COIN_INITIAL_VALUE if genesis else Decimal('0')
        event = {
            "event": "ADD_USER",
            "user": name,
            "genesis": genesis,
            "species": species,
            "karma": "0",
            "coin_id": coin_id,
            "coins_owned": [],
            "initial_root_value": str(root_value),
            "consent": True,
            "root_value": str(root_value),
            "timestamp": ts(),
        }
        # Log then apply
        self.logchain.add(event)
        self._apply_event(event)
        self.hooks.fire_hooks("user_added", user=self.users[name])
        logging.info(f"User added: {name}")
        return self.users[name]

    @acquire_agent_lock
    def mint_fractional_post(self, user_name: str, improvement: str, references: List[Dict]) -> str:
        if user_name not in self.users:
            raise InvalidInputError(f"User '{user_name}' not found")

        user = self.users[user_name]

        if not user.check_mint_rate_limit():
            raise RateLimitError(f"User '{user_name}' exceeded mint limit")

        if len(improvement) < Config.MIN_IMPROVEMENT_LEN:
            raise ImprovementRequiredError("Improvement description too short")

        root_coin = self.coins.get(user.root_coin_id)
        if not root_coin or root_coin.value < Config.FRACTIONAL_COIN_MIN_VALUE:
            raise InsufficientFundsError("Insufficient root coin value to mint")

        new_coin_id = uuid.uuid4().hex
        mint_value = root_coin.value * Config.MAX_FRACTION_START
        event = {
            "event": "MINT",
            "user": user_name,
            "coin": new_coin_id,
            "val": str(mint_value),
            "root_coin_id": user.root_coin_id,
            "genesis_creator": root_coin.genesis_creator,
            "references": references,
            "improvement": improvement,
            "fraction_percent": str(Config.MAX_FRACTION_START),
            "ancestors": root_coin.ancestors + [root_coin.coin_id],
            "timestamp": ts(),
        }
        self.logchain.add(event)
        self._apply_event(event)
        self.hooks.fire_hooks("coin_minted", user=user, coin_id=new_coin_id)
        logging.info(f"User {user_name} minted coin {new_coin_id}")
        return new_coin_id

    @acquire_agent_lock
    def react_to_coin(self, reactor: str, coin_id: str, emoji: str, message: Optional[str] = None):
        if reactor not in self.users:
            raise InvalidInputError(f"Reactor '{reactor}' not found")
        if coin_id not in self.coins:
            raise InvalidInputError(f"Coin '{coin_id}' not found")
        if not is_valid_emoji(emoji):
            raise EmojiRequiredError(f"Emoji '{emoji}' not supported")

        reactor_user = self.users[reactor]
        if not reactor_user.check_reaction_rate_limit():
            raise RateLimitError("Reaction rate limit exceeded")

        coin_value_reactor = Decimal('1')
        coin_value_creator = Decimal('0.5')
        coin_value_treasury = Decimal('0.5')

        event = {
            "event": "REACT",
            "reactor": reactor,
            "coin": coin_id,
            "emoji": emoji,
            "message": message or "",
            "coin_value_reactor": str(coin_value_reactor),
            "coin_value_creator": str(coin_value_creator),
            "coin_value_treasury": str(coin_value_treasury),
            "viral_decay": str(Config.VIRAL_DECAY),
            "emoji_weight_used": str(self.emoji_market.get_weight(emoji)),
            "network_bonus": "1",
            "decay_factor_used": "1",
            "timestamp": ts(),
        }
        self.logchain.add(event)
        self._apply_event(event)
        self.hooks.fire_hooks("coin_reacted", reactor=reactor, coin_id=coin_id, emoji=emoji)
        logging.info(f"User {reactor} reacted to coin {coin_id} with {emoji}")

    @acquire_agent_lock
    def list_coin_for_sale(self, seller_name: str, coin_id: str, price: Decimal) -> str:
        if seller_name not in self.users:
            raise InvalidInputError(f"Seller '{seller_name}' not found.")
        seller_user = self.users[seller_name]

        if coin_id not in self.coins:
            raise InvalidInputError(f"Coin '{coin_id}' not found.")
        coin = self.coins[coin_id]

        if coin.owner != seller_name:
            raise TradeError(f"User '{seller_name}' does not own coin '{coin_id}'.")
        if price <= 0:
            raise InvalidInputError("Price must be positive.")

        for listing in self.marketplace_listings.values():
            if listing["coin_id"] == coin_id and listing["status"] == "active":
                raise TradeError(f"Coin '{coin_id}' is already listed for sale.")

        listing_id = uuid.uuid4().hex

        event = {
            "event": "LIST_COIN_FOR_SALE",
            "listing_id": listing_id,
            "seller": seller_name,
            "coin_id": coin_id,
            "price": str(price),
            "timestamp": ts(),
        }
        self.logchain.add(event)
        self._apply_event(event)
        self.hooks.fire_hooks("coin_listed_for_sale", listing_id=listing_id)
        logging.info(f"Coin {coin_id} listed for sale by {seller_name} at {price}")
        return listing_id

    @acquire_agent_lock
    def buy_coin(self, buyer_name: str, listing_id: str):
        if buyer_name not in self.users:
            raise InvalidInputError(f"Buyer '{buyer_name}' not found.")
        if listing_id not in self.marketplace_listings:
            raise InvalidInputError(f"Listing '{listing_id}' not found.")

        listing = self.marketplace_listings[listing_id]
        if listing["status"] != "active":
            raise TradeError(f"Listing '{listing_id}' is not active.")

        seller_name = listing["seller"]
        coin_id = listing["coin_id"]
        price = Decimal(listing["price"])
        fee = price * Config.MARKET_FEE
        total_cost = price + fee

        buyer = self.users[buyer_name]
        if buyer.root_coin_id is None or self.coins[buyer.root_coin_id].value < total_cost:
            raise InsufficientFundsError("Buyer does not have enough funds.")

        if seller_name not in self.users or coin_id not in self.coins:
            raise InvalidInputError("Seller or coin invalid.")

        event = {
            "event": "BUY_COIN",
            "buyer": buyer_name,
            "seller": seller_name,
            "coin_id": coin_id,
            "price": str(price),
            "fee": str(fee),
            "listing_id": listing_id,
            "timestamp": ts(),
        }
        self.logchain.add(event)
        self._apply_event(event)
        self.hooks.fire_hooks("coin_bought", listing_id=listing_id, buyer=buyer_name)
        logging.info(f"User {buyer_name} bought coin {coin_id} from {seller_name} for {price}")
        return listing_id

    @acquire_agent_lock
    def transfer_coin(self, from_user: str, to_user: str, coin_id: str):
        if from_user not in self.users:
            raise InvalidInputError(f"Sender '{from_user}' not found.")
        if to_user not in self.users:
            raise InvalidInputError(f"Receiver '{to_user}' not found.")
        if coin_id not in self.coins:
            raise InvalidInputError(f"Coin '{coin_id}' not found.")
        coin = self.coins[coin_id]
        if coin.owner != from_user:
            raise TradeError(f"User '{from_user}' does not own coin '{coin_id}'.")

        event = {
            "event": "TRANSFER_COIN",
            "from_user": from_user,
            "to_user": to_user,
            "coin_id": coin_id,
            "timestamp": ts(),
        }
        self.logchain.add(event)
        self._apply_event(event)
        self.hooks.fire_hooks("coin_transferred", coin_id=coin_id, from_user=from_user, to_user=to_user)
        logging.info(f"Coin {coin_id} transferred from {from_user} to {to_user}")

    @acquire_agent_lock
    def create_proposal(self, creator: str, description: str, target: str, payload: dict) -> str:
        if creator not in self.users:
            raise InvalidInputError(f"Creator '{creator}' not found.")

        proposal_id = uuid.uuid4().hex
        event = {
            "event": "CREATE_PROPOSAL",
            "proposal_id": proposal_id,
            "creator": creator,
            "description": description,
            "target": target,
            "payload": payload,
            "timestamp": ts(),
        }
        self.logchain.add(event)
        self._apply_event(event)
        self.hooks.fire_hooks("proposal_created", proposal_id=proposal_id)
        logging.info(f"Proposal {proposal_id} created by {creator}")
        return proposal_id

    @acquire_agent_lock
    def vote_proposal(self, proposal_id: str, voter: str, vote: str):
        if voter not in self.users:
            raise InvalidInputError(f"Voter '{voter}' not found.")
        if proposal_id not in self.proposals:
            raise InvalidInputError(f"Proposal '{proposal_id}' not found.")
        if vote not in ("yes", "no"):
            raise VoteError("Vote must be 'yes' or 'no'.")

        event = {
            "event": "VOTE",
            "proposal_id": proposal_id,
            "voter": voter,
            "vote": vote,
            "timestamp": ts(),
        }
        self.logchain.add(event)
        self._apply_event(event)
        self.hooks.fire_hooks("proposal_voted", proposal_id=proposal_id, voter=voter, vote=vote)
        logging.info(f"User {voter} voted '{vote}' on proposal {proposal_id}")

    @acquire_agent_lock
    def execute_proposal(self, proposal_id: str):
        if proposal_id not in self.proposals:
            raise InvalidInputError(f"Proposal '{proposal_id}' not found.")

        proposal = self.proposals[proposal_id]
        if not proposal.is_approved(self.users):
            raise VoteError("Proposal not approved by supermajority.")

        event = {
            "event": "EXECUTE_PROPOSAL",
            "proposal_id": proposal_id,
            "timestamp": ts(),
        }
        self.logchain.add(event)
        self._apply_event(event)
        self.hooks.fire_hooks("proposal_executed", proposal_id=proposal_id)
        logging.info(f"Proposal {proposal_id} executed")

    @acquire_agent_lock
    def close_proposal(self, proposal_id: str, status: str):
        if proposal_id not in self.proposals:
            raise InvalidInputError(f"Proposal '{proposal_id}' not found.")
        if status not in ("closed", "rejected", "expired"):
            raise InvalidInputError(f"Invalid status '{status}' for closing proposal.")

        event = {
            "event": "PROPOSAL_CLOSED",
            "proposal_id": proposal_id,
            "status": status,
            "timestamp": ts(),
        }
        self.logchain.add(event)
        self._apply_event(event)
        self.hooks.fire_hooks("proposal_closed", proposal_id=proposal_id, status=status)
        logging.info(f"Proposal {proposal_id} closed with status '{status}'")

    @acquire_agent_lock
    def apply_daily_decay(self):
        day = today()
        if self._last_decay_day == day:
            return  # already applied today

        # Calculate treasury allocation
        allocation = self.treasury * Config.TREASURY_ACTIVE_ALLOCATION_PCT
        event = {
            "event": "DAILY_DECAY",
            "treasury_allocation": str(allocation),
            "timestamp": ts(),
        }
        self.logchain.add(event)
        self._apply_event(event)

        # Apply karma decay to all users
        for user in self.users.values():
            user.apply_daily_karma_decay()

        self._last_decay_day = day
        self.hooks.fire_hooks("daily_decay_applied", allocation=allocation)
        logging.info(f"Daily decay applied, treasury allocation: {allocation}")

    # Snapshot loading and saving:
    def load_state(self):
        try:
            with open(self.snapshot_file, "r", encoding="utf-8") as f:
                data = json.load(f)
            # Load users
            self.users = {u["name"]: User.from_dict(u) for u in data.get("users", [])}
            # Load coins
            self.coins = {c["coin_id"]: Coin.from_dict(c) for c in data.get("coins", [])}
            # Load proposals
            self.proposals = {p["proposal_id"]: Proposal.from_dict(p) for p in data.get("proposals", [])}
            self.treasury = Decimal(data.get("treasury", "0"))
            self.treasury_active_fund = Decimal(data.get("treasury_active_fund", "0"))
            self.marketplace_listings = data.get("marketplace_listings", {})
            self._last_decay_day = data.get("last_decay_day")
            logging.info("State loaded from snapshot.")
        except FileNotFoundError:
            logging.info("No snapshot found, starting fresh.")
        except Exception as e:
            logging.error(f"Failed to load snapshot: {e}")

    def save_snapshot(self):
        try:
            data = {
                "users": [u.to_dict() for u in self.users.values()],
                "coins": [c.to_dict() for c in self.coins.values()],
                "proposals": [p.to_dict() for p in self.proposals.values()],
                "treasury": str(self.treasury),
                "treasury_active_fund": str(self.treasury_active_fund),
                "marketplace_listings": self.marketplace_listings,
                "last_decay_day": self._last_decay_day,
            }
            with open(self.snapshot_file, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2)
            logging.info("State snapshot saved.")
        except Exception as e:
            logging.error(f"Failed to save snapshot: {e}")

    def _apply_event(self, event: Dict[str, Any]):
        # Core event applying without validation (log is source of truth)
        et = event["event"]
        timestamp = event.get("timestamp", ts())
        try:
            if et == "ADD_USER":
                name = event["user"]
                if name not in self.users:
                    self._do_add_user(
                        name=name,
                        is_genesis=event.get("genesis", False),
                        species=event.get("species", "human"),
                        karma=Decimal(event.get("karma", '0')),
                        join_time=datetime.datetime.fromisoformat(timestamp),
                        last_active=datetime.datetime.fromisoformat(timestamp),
                        root_coin_id=event["coin_id"],
                        coins_owned=event.get("coins_owned", []),
                        initial_root_value=Decimal(event["initial_root_value"]),
                        consent=event.get("consent", True),
                        root_coin_value=Decimal(event["root_value"])
                    )
            elif et == "MINT":
                self._do_mint_coin(
                    user_name=event["user"],
                    new_coin_id=event["coin"],
                    mint_value=Decimal(event["val"]),
                    new_coin_value=Decimal(event.get("new_coin_value", '0')),
                    root_coin_id=event["root_coin_id"],
                    genesis_creator=event.get("genesis_creator", ""),
                    references=event.get("references", []),
                    improvement=event.get("improvement", ""),
                    fractional_pct=Decimal(event.get("fraction_percent", '0')),
                    ancestors=event.get("ancestors", []),
                    created_at=timestamp
                )
            elif et == "REACT":
                self._do_react_to_coin(
                    reactor=event["reactor"],
                    coin_id=event["coin"],
                    emoji=event["emoji"],
                    message=event.get("message"),
                    coin_value_reactor=Decimal(event["coin_value_reactor"]),
                    coin_value_creator=Decimal(event["coin_value_creator"]),
                    coin_value_treasury=Decimal(event["coin_value_treasury"]),
                    viral_decay=Decimal(event.get("viral_decay", '1')),
                    emoji_weight_used=Decimal(event.get("emoji_weight_used", '1')),
                    network_bonus=Decimal(event.get("network_bonus", '1')),
                    decay_factor_used=Decimal(event.get("decay_factor_used", '1')),
                    timestamp=timestamp
                )
            elif et == "LIST_COIN_FOR_SALE":
                self._do_list_coin_for_sale(
                    listing_id=event["listing_id"],
                    seller=event["seller"],
                    coin_id=event["coin_id"],
                    price=Decimal(event["price"]),
                    created_at=timestamp
                )
            elif et == "BUY_COIN":
                self._do_buy_coin(
                    buyer=event["buyer"],
                    seller=event["seller"],
                    coin_id=event["coin_id"],
                    price=Decimal(event["price"]),
                    fee_amount=Decimal(event["fee"]),
                    listing_id=event["listing_id"],
                    sold_at=timestamp
                )
            elif et == "TRANSFER_COIN":
                self._do_transfer_coin(
                    from_user=event["from_user"],
                    to_user=event["to_user"],
                    coin_id=event["coin_id"]
                )
            elif et == "CREATE_PROPOSAL":
                self._do_create_proposal(
                    proposal_id=event["proposal_id"],
                    creator=event["creator"],
                    description=event["description"],
                    target=event["target"],
                    payload=event["payload"],
                    created_at=timestamp
                )
            elif et == "VOTE":
                self._do_vote_proposal(
                    proposal_id=event["proposal_id"],
                    voter=event["voter"],
                    vote=event["vote"]
                )
            elif et == "EXECUTE_PROPOSAL":
                self._do_execute_proposal(
                    proposal_id=event["proposal_id"]
                )
            elif et == "PROPOSAL_CLOSED":
                self._do_close_proposal(
                    proposal_id=event["proposal_id"],
                    status=event["status"]
                )
            elif et == "DAILY_DECAY":
                self._do_daily_decay(
                    treasury_allocation=Decimal(event["treasury_allocation"]),
                    timestamp=timestamp
                )
            else:
                logging.debug(f"Unknown event type {et} encountered during replay.")

        except Exception as e:
            logging.error(f"Error applying event {et} during replay: {e}. Event: {json.dumps(event)}")

